diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/kernel.config OCTEON-SDKsffnand/linux/kernel/kernel.config
--- OCTEON-SDK.orig/linux/kernel/kernel.config	2017-02-14 11:55:06.461532804 +0800
+++ OCTEON-SDKsffnand/linux/kernel/kernel.config	2017-02-14 12:04:22.037744497 +0800
@@ -52,8 +52,8 @@ CONFIG_CAVIUM_OCTEON_SOC=y
 # CONFIG_MIPS_PARAVIRT is not set
 # CONFIG_ALCHEMY_GPIO_INDIRECT is not set
 # CONFIG_MAPPED_KERNEL is not set
-CONFIG_CAVIUM_OCTEON2=y
-CONFIG_CAVIUM_CN63XXP1=y
+# CONFIG_CAVIUM_OCTEON2 is not set
+# CONFIG_CAVIUM_CN63XXP1 is not set
 CONFIG_CAVIUM_OCTEON_EXTRA_CVMSEG=0
 CONFIG_FAST_ACCESS_TO_THREAD_POINTER=y
 # CONFIG_CAVIUM_OCTEON_USER_IO is not set
@@ -69,12 +69,11 @@ CONFIG_CAVIUM_OCTEON_LOCK_L2_LOW_LEVEL_I
 CONFIG_CAVIUM_OCTEON_LOCK_L2_INTERRUPT=y
 CONFIG_CAVIUM_OCTEON_LOCK_L2_MEMCPY=y
 CONFIG_CAVIUM_RESERVE32=0
-# CONFIG_CAVIUM_OCTEON_NAND is not set
+CONFIG_CAVIUM_OCTEON_NAND=y
 CONFIG_CAVIUM_OCTEON_RAPIDIO=y
 CONFIG_RAPIDIO=y
 CONFIG_CAVIUM_OCTEON_ERROR_TREE=y
-# CONFIG_CAVIUM_OCTEON_KERNEL_CRYPTO is not set
-CONFIG_CAVIUM_OCTEON_PERF=y
+CONFIG_CAVIUM_OCTEON_KERNEL_CRYPTO=y
 CONFIG_OCTEON_FPA3=y
 CONFIG_ARCH_SPARSEMEM_ENABLE=y
 CONFIG_IOMMU_HELPER=y
@@ -83,6 +82,8 @@ CONFIG_SWIOTLB=y
 # CONFIG_DISABLE_ELF_NOTE_HEADER is not set
 # CONFIG_OCTEON_ILM is not set
 # CONFIG_OCTEON_ERROR_INJECTOR is not set
+CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD=y
+CONFIG_CAVIUM_OCTEON_IPSEC=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 # CONFIG_ARCH_HAS_ILOG2_U32 is not set
 # CONFIG_ARCH_HAS_ILOG2_U64 is not set
@@ -137,12 +138,10 @@ CONFIG_MIPS_MT_DISABLED=y
 CONFIG_64BIT_PHYS_ADDR=y
 CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
 CONFIG_CPU_HAS_SYNC=y
-CONFIG_NUMA=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+# CONFIG_NUMA is not set
 CONFIG_SYS_SUPPORTS_NUMA=y
-CONFIG_NODES_SHIFT=1
-CONFIG_HW_PERF_EVENTS=y
 CONFIG_SPARSEMEM=y
-CONFIG_NEED_MULTIPLE_NODES=y
 CONFIG_HAVE_MEMORY_PRESENT=y
 CONFIG_SPARSEMEM_STATIC=y
 CONFIG_HAVE_MEMBLOCK=y
@@ -168,7 +167,7 @@ CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y
 CONFIG_SMP=y
 CONFIG_SYS_SUPPORTS_SMP=y
 CONFIG_NR_CPUS_DEFAULT_64=y
-CONFIG_NR_CPUS=48
+CONFIG_NR_CPUS=32
 CONFIG_MIPS_NR_CPU_NR_MAP_1024=y
 CONFIG_MIPS_NR_CPU_NR_MAP=1024
 # CONFIG_HZ_48 is not set
@@ -187,7 +186,7 @@ CONFIG_PREEMPT_NONE=y
 # CONFIG_PREEMPT_RT_FULL is not set
 # CONFIG_KEXEC is not set
 # CONFIG_CRASH_DUMP is not set
-CONFIG_SECCOMP=y
+# CONFIG_SECCOMP is not set
 CONFIG_USE_OF=y
 CONFIG_LOCKDEP_SUPPORT=y
 CONFIG_STACKTRACE_SUPPORT=y
@@ -200,15 +199,15 @@ CONFIG_BUILDTIME_EXTABLE_SORT=y
 #
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_CROSS_COMPILE=""
-CONFIG_LOCALVERSION="-Cavium-Octeon"
+CONFIG_LOCALVERSION=""
 # CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_DEFAULT_HOSTNAME=""
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 CONFIG_POSIX_MQUEUE=y
 CONFIG_POSIX_MQUEUE_SYSCTL=y
-CONFIG_FHANDLE=y
+# CONFIG_FHANDLE is not set
 # CONFIG_AUDIT is not set
 CONFIG_HAVE_GENERIC_HARDIRQS=y
 
@@ -222,7 +221,6 @@ CONFIG_IRQ_DOMAIN=y
 CONFIG_HANDLE_DOMAIN_IRQ=y
 CONFIG_IRQ_DOMAIN_DEBUG=y
 CONFIG_IRQ_FORCED_THREADING=y
-CONFIG_SPARSE_IRQ=y
 CONFIG_GENERIC_CLOCKEVENTS=y
 CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_GENERIC_CMOS_UPDATE=y
@@ -270,13 +268,7 @@ CONFIG_UIDGID_CONVERTED=y
 # CONFIG_SCHED_AUTOGROUP is not set
 # CONFIG_SYSFS_DEPRECATED is not set
 CONFIG_RELAY=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_RD_GZIP=y
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_RD_LZO is not set
+# CONFIG_BLK_DEV_INITRD is not set
 # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
 CONFIG_SYSCTL=y
 CONFIG_ANON_INODES=y
@@ -284,7 +276,7 @@ CONFIG_HOTPLUG=y
 CONFIG_EXPERT=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
-CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_ALL is not set
 CONFIG_PRINTK=y
 CONFIG_BUG=y
 CONFIG_ELF_CORE=y
@@ -296,7 +288,7 @@ CONFIG_SIGNALFD=y
 CONFIG_TIMERFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
-CONFIG_AIO=y
+# CONFIG_AIO is not set
 CONFIG_PCI_QUIRKS=y
 CONFIG_EMBEDDED=y
 CONFIG_HAVE_PERF_EVENTS=y
@@ -305,13 +297,11 @@ CONFIG_PERF_USE_VMALLOC=y
 #
 # Kernel Performance Events And Counters
 #
-CONFIG_PERF_EVENTS=y
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# CONFIG_PERF_EVENTS is not set
 CONFIG_VM_EVENT_COUNTERS=y
-CONFIG_SLUB_DEBUG=y
 # CONFIG_COMPAT_BRK is not set
-# CONFIG_SLAB is not set
-CONFIG_SLUB=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
 # CONFIG_SLOB is not set
 # CONFIG_PROFILING is not set
 CONFIG_HAVE_OPROFILE=y
@@ -442,6 +432,7 @@ CONFIG_ARCH_HIBERNATION_POSSIBLE=y
 # CONFIG_HIBERNATION is not set
 # CONFIG_PM_RUNTIME is not set
 CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
 
 #
 # Networking options
@@ -451,24 +442,33 @@ CONFIG_PACKET=y
 CONFIG_UNIX=y
 # CONFIG_UNIX_DIAG is not set
 CONFIG_XFRM=y
-CONFIG_XFRM_ALGO=m
-CONFIG_XFRM_USER=m
+CONFIG_XFRM_ALGO=y
+CONFIG_XFRM_USER=y
 # CONFIG_XFRM_SUB_POLICY is not set
 # CONFIG_XFRM_MIGRATE is not set
 # CONFIG_XFRM_STATISTICS is not set
-CONFIG_NET_KEY=m
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=y
 # CONFIG_NET_KEY_MIGRATE is not set
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_ROUTE_CLASSID=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 CONFIG_IP_PNP_RARP=y
 # CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE_DEMUX is not set
-# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IP_TUNNEL=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
 CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
 CONFIG_IP_PIMSM_V1=y
 CONFIG_IP_PIMSM_V2=y
 # CONFIG_ARPD is not set
@@ -476,9 +476,9 @@ CONFIG_SYN_COOKIES=y
 # CONFIG_NET_IPVTI is not set
 CONFIG_INET_AH=m
 CONFIG_INET_ESP=m
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
 CONFIG_INET_XFRM_MODE_TRANSPORT=y
 CONFIG_INET_XFRM_MODE_TUNNEL=y
 CONFIG_INET_XFRM_MODE_BEET=y
@@ -490,16 +490,16 @@ CONFIG_INET_TCP_DIAG=y
 CONFIG_TCP_CONG_CUBIC=y
 CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
-CONFIG_IPV6=m
-# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
 # CONFIG_IPV6_ROUTER_PREF is not set
 # CONFIG_IPV6_OPTIMISTIC_DAD is not set
-# CONFIG_INET6_AH is not set
-# CONFIG_INET6_ESP is not set
-# CONFIG_INET6_IPCOMP is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
 # CONFIG_IPV6_MIP6 is not set
-# CONFIG_INET6_XFRM_TUNNEL is not set
-# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
 CONFIG_INET6_XFRM_MODE_TRANSPORT=m
 CONFIG_INET6_XFRM_MODE_TUNNEL=m
 CONFIG_INET6_XFRM_MODE_BEET=m
@@ -507,25 +507,234 @@ CONFIG_INET6_XFRM_MODE_BEET=m
 # CONFIG_IPV6_SIT is not set
 # CONFIG_IPV6_TUNNEL is not set
 # CONFIG_IPV6_GRE is not set
-# CONFIG_IPV6_MULTIPLE_TABLES is not set
-# CONFIG_IPV6_MROUTE is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+# CONFIG_IPV6_MROUTE_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_PIMSM_V2 is not set
 # CONFIG_NETLABEL is not set
 # CONFIG_NETWORK_SECMARK is not set
 # CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-# CONFIG_NETFILTER is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+# CONFIG_BRIDGE_NETFILTER is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+# CONFIG_NF_CT_PROTO_SCTP is not set
+# CONFIG_NF_CT_PROTO_UDPLITE is not set
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=m
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+# CONFIG_NF_CONNTRACK_PPTP is not set
+# CONFIG_NF_CONNTRACK_SANE is not set
+# CONFIG_NF_CONNTRACK_SIP is not set
+# CONFIG_NF_CONNTRACK_TFTP is not set
+# CONFIG_NF_CT_NETLINK is not set
+# CONFIG_NF_CT_NETLINK_TIMEOUT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE_CT is not set
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+# CONFIG_NF_NAT_AMANDA is not set
+CONFIG_NF_NAT_FTP=m
+# CONFIG_NF_NAT_IRC is not set
+# CONFIG_NF_NAT_SIP is not set
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+CONFIG_NETFILTER_XT_SET=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+# CONFIG_NETFILTER_XT_TARGET_CONNMARK is not set
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+# CONFIG_NETFILTER_XT_TARGET_IMQ is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_BPF is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+# CONFIG_NETFILTER_XT_MATCH_CONNMARK is not set
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ECN=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+CONFIG_IP_SET=y
+CONFIG_IP_SET_MAX=256
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+# CONFIG_NF_CONNTRACK_PROC_COMPAT is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_NF_NAT_IPV4=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+CONFIG_IP_NF_TARGET_REDIRECT=m
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_IP_NF_MANGLE=m
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+CONFIG_IP_NF_TARGET_ECN=m
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=m
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+# CONFIG_IP6_NF_SECURITY is not set
+# CONFIG_NF_NAT_IPV6 is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
 # CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1 is not set
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_NONE is not set
+CONFIG_SCTP_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_COOKIE_HMAC_SHA1 is not set
 # CONFIG_RDS is not set
 # CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_L2TP is not set
-CONFIG_STP=m
-CONFIG_BRIDGE=m
+CONFIG_ATM=m
+# CONFIG_ATM_CLIP is not set
+# CONFIG_ATM_LANE is not set
+CONFIG_ATM_BR2684=m
+CONFIG_ATM_BR2684_IPFILTER=y
+CONFIG_L2TP=m
+# CONFIG_L2TP_DEBUGFS is not set
+CONFIG_L2TP_V3=y
+# CONFIG_L2TP_IP is not set
+# CONFIG_L2TP_ETH is not set
+CONFIG_STP=y
+CONFIG_GARP=y
+CONFIG_MRP=y
+CONFIG_BRIDGE=y
 CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_BRIDGE_VLAN_FILTERING=y
 CONFIG_HAVE_NET_DSA=y
-# CONFIG_VLAN_8021Q is not set
+CONFIG_VLAN_8021Q=y
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
 # CONFIG_DECNET is not set
-CONFIG_LLC=m
+CONFIG_LLC=y
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
@@ -533,7 +742,69 @@ CONFIG_LLC=m
 # CONFIG_LAPB is not set
 # CONFIG_PHONET is not set
 # CONFIG_IEEE802154 is not set
-# CONFIG_NET_SCHED is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+# CONFIG_NET_SCH_ATM is not set
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_CHOKE=m
+CONFIG_NET_SCH_QFQ=m
+CONFIG_NET_SCH_CODEL=m
+CONFIG_NET_SCH_FQ_CODEL=y
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_SCH_PLUG=m
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+# CONFIG_CLS_U32_PERF is not set
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+# CONFIG_NET_EMATCH_IPSET is not set
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_ACT_CSUM=m
+CONFIG_NET_CLS_IND=y
+CONFIG_NET_SCH_FIFO=y
 # CONFIG_DCB is not set
 CONFIG_DNS_RESOLVER=y
 # CONFIG_BATMAN_ADV is not set
@@ -555,7 +826,28 @@ CONFIG_BQL=y
 # CONFIG_IRDA is not set
 # CONFIG_BT is not set
 # CONFIG_AF_RXRPC is not set
-# CONFIG_WIRELESS is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_LIB80211=y
+CONFIG_LIB80211_CRYPT_WEP=y
+CONFIG_LIB80211_CRYPT_CCMP=y
+CONFIG_LIB80211_CRYPT_TKIP=y
+# CONFIG_LIB80211_DEBUG is not set
+# CONFIG_MAC80211 is not set
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
@@ -571,11 +863,13 @@ CONFIG_BQL=y
 # Generic Driver Options
 #
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_DEVTMPFS=y
-# CONFIG_DEVTMPFS_MOUNT is not set
+# CONFIG_DEVTMPFS is not set
 CONFIG_STANDALONE=y
 CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
 # CONFIG_DEBUG_DRIVER is not set
 # CONFIG_DEBUG_DEVRES is not set
 # CONFIG_SYS_HYPERVISOR is not set
@@ -649,7 +943,7 @@ CONFIG_MTD_COMPLEX_MAPPINGS=y
 #
 # CONFIG_MTD_PMC551 is not set
 # CONFIG_MTD_DATAFLASH is not set
-CONFIG_MTD_M25P80=m
+CONFIG_MTD_M25P80=y
 CONFIG_M25PXX_USE_FAST_READ=y
 # CONFIG_MTD_SST25L is not set
 CONFIG_MTD_SLRAM=y
@@ -936,6 +1230,7 @@ CONFIG_NET_CORE=y
 # CONFIG_EQUALIZER is not set
 # CONFIG_NET_FC is not set
 CONFIG_MII=y
+CONFIG_IFB=m
 # CONFIG_NET_TEAM is not set
 # CONFIG_MACVLAN is not set
 # CONFIG_VXLAN is not set
@@ -943,15 +1238,29 @@ CONFIG_MII=y
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
 # CONFIG_RIONET is not set
-# CONFIG_TUN is not set
+# CONFIG_IMQ is not set
+CONFIG_TUN=m
 # CONFIG_VETH is not set
 # CONFIG_ARCNET is not set
+CONFIG_ATM_DRIVERS=y
+# CONFIG_ATM_DUMMY is not set
+# CONFIG_ATM_TCP is not set
+# CONFIG_ATM_LANAI is not set
+# CONFIG_ATM_ENI is not set
+# CONFIG_ATM_FIRESTREAM is not set
+# CONFIG_ATM_ZATM is not set
+# CONFIG_ATM_NICSTAR is not set
+# CONFIG_ATM_IDT77252 is not set
+# CONFIG_ATM_AMBASSADOR is not set
+# CONFIG_ATM_HORIZON is not set
+# CONFIG_ATM_IA is not set
+# CONFIG_ATM_FORE200E is not set
+# CONFIG_ATM_HE is not set
+# CONFIG_ATM_SOLOS is not set
 
 #
 # CAIF transport drivers
 #
-CONFIG_VHOST_NET=y
-CONFIG_VHOST_RING=y
 
 #
 # Distributed Switch Architecture drivers
@@ -983,37 +1292,31 @@ CONFIG_ETHERNET=y
 # CONFIG_NET_VENDOR_HP is not set
 CONFIG_NET_VENDOR_INTEL=y
 # CONFIG_E100 is not set
-CONFIG_E1000=y
+# CONFIG_E1000 is not set
 CONFIG_E1000E=y
-CONFIG_IGB=y
-CONFIG_IGB_HWMON=y
+# CONFIG_IGB is not set
 # CONFIG_IGBVF is not set
 # CONFIG_IXGB is not set
 # CONFIG_IXGBE is not set
 # CONFIG_IXGBEVF is not set
-CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_NET_VENDOR_I825XX is not set
 # CONFIG_IP1000 is not set
 # CONFIG_JME is not set
 # CONFIG_NET_VENDOR_MARVELL is not set
 # CONFIG_NET_VENDOR_MELLANOX is not set
-CONFIG_NET_VENDOR_MICREL=y
-# CONFIG_KS8851 is not set
-# CONFIG_KS8851_MLL is not set
-# CONFIG_KSZ884X_PCI is not set
+# CONFIG_NET_VENDOR_MICREL is not set
 # CONFIG_NET_VENDOR_MICROCHIP is not set
 # CONFIG_NET_VENDOR_MYRI is not set
 # CONFIG_FEALNX is not set
 # CONFIG_NET_VENDOR_NATSEMI is not set
 # CONFIG_NET_VENDOR_NVIDIA is not set
 CONFIG_OCTEON_BGX_NEXUS=y
-CONFIG_OCTEON_SRIO_NEXUS=m
 CONFIG_OCTEON_COMMON_NEXUS=y
 CONFIG_OCTEON_BGX_PORT=y
-CONFIG_OCTEON3_ETHERNET=m
-CONFIG_OCTEON3_ETHERNET_SRIO=m
-CONFIG_OCTEON_ETHERNET=m
+# CONFIG_OCTEON3_ETHERNET is not set
+CONFIG_OCTEON_ETHERNET=y
 CONFIG_OCTEON_ETHERNET_MEM=y
-CONFIG_OCTEON_POW_ONLY_ETHERNET=m
+CONFIG_OCTEON_POW_ONLY_ETHERNET=y
 CONFIG_OCTEON_MGMT_ETHERNET=y
 CONFIG_NET_VENDOR_OCTEON=y
 CONFIG_OCTEON_ETHERNET_COMMON=y
@@ -1042,7 +1345,7 @@ CONFIG_PHYLIB=y
 #
 # MII PHY device drivers
 #
-# CONFIG_AT803X_PHY is not set
+CONFIG_AT803X_PHY=y
 # CONFIG_AMD_PHY is not set
 CONFIG_AQUANTIA_PHY=y
 CONFIG_MARVELL_PHY=y
@@ -1051,14 +1354,14 @@ CONFIG_MARVELL_PHY=y
 # CONFIG_LXT_PHY is not set
 # CONFIG_CICADA_PHY is not set
 # CONFIG_VITESSE_PHY is not set
-CONFIG_VSC848X_PHY=y
-CONFIG_VSC8490_PHY=y
-CONFIG_TLK10232_PHY=y
+# CONFIG_VSC848X_PHY is not set
+# CONFIG_VSC8490_PHY is not set
+# CONFIG_TLK10232_PHY is not set
 # CONFIG_SMSC_PHY is not set
 CONFIG_BROADCOM_PHY=y
 CONFIG_BCM87XX_PHY=y
 CONFIG_CS4318_PHY=y
-CONFIG_MARVELL_88X3120_PHY=y
+# CONFIG_MARVELL_88X3120_PHY is not set
 # CONFIG_ICPLUS_PHY is not set
 # CONFIG_REALTEK_PHY is not set
 # CONFIG_NATIONAL_PHY is not set
@@ -1073,8 +1376,20 @@ CONFIG_MDIO_BUS_MUX=y
 CONFIG_MDIO_BUS_MUX_GPIO=y
 # CONFIG_MDIO_BUS_MUX_MMIOREG is not set
 CONFIG_MICREL_KS8995MA=y
-# CONFIG_PPP is not set
+CONFIG_PPP=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_DEFLATE is not set
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOATM=m
+CONFIG_PPPOE=m
+CONFIG_PPTP=m
+CONFIG_PPPOL2TP=m
+CONFIG_PPP_ASYNC=m
+# CONFIG_PPP_SYNC_TTY is not set
 # CONFIG_SLIP is not set
+CONFIG_SLHC=m
 
 #
 # USB Network Adapters
@@ -1084,9 +1399,47 @@ CONFIG_MICREL_KS8995MA=y
 # CONFIG_USB_PEGASUS is not set
 # CONFIG_USB_RTL8150 is not set
 # CONFIG_USB_RTL8152 is not set
-# CONFIG_USB_USBNET is not set
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_CDC_NCM=m
+CONFIG_USB_NET_CDC_MBIM=m
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_SMSC75XX is not set
+# CONFIG_USB_NET_SMSC95XX is not set
+# CONFIG_USB_NET_GL620A is not set
+# CONFIG_USB_NET_NET1080 is not set
+CONFIG_USB_NET_PLUSB=y
+# CONFIG_USB_NET_MCS7830 is not set
+# CONFIG_USB_NET_RNDIS_HOST is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+CONFIG_USB_NET_QMI_WWAN=m
+# CONFIG_USB_NET_INT51X1 is not set
 # CONFIG_USB_IPHETH is not set
-# CONFIG_WLAN is not set
+CONFIG_USB_SIERRA_NET=y
+# CONFIG_USB_VL600 is not set
+CONFIG_WLAN=y
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_ATH_CARDS is not set
+# CONFIG_BRCMFMAC is not set
+CONFIG_HOSTAP=y
+# CONFIG_HOSTAP_FIRMWARE is not set
+# CONFIG_HOSTAP_PLX is not set
+# CONFIG_HOSTAP_PCI is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_HERMES is not set
+# CONFIG_WL_TI is not set
+# CONFIG_MWIFIEX is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -1184,7 +1537,7 @@ CONFIG_HW_RANDOM_OCTEON=m
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_TCG_TPM is not set
 CONFIG_DEVPORT=y
-CONFIG_OCTEON_OCLA=m
+# CONFIG_OCTEON_OCLA is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 # CONFIG_I2C_COMPAT is not set
@@ -1199,7 +1552,6 @@ CONFIG_I2C_MUX=y
 CONFIG_I2C_MUX_PCA9541=y
 CONFIG_I2C_MUX_PCA954x=y
 CONFIG_I2C_HELPER_AUTO=y
-CONFIG_I2C_ALGOBIT=y
 
 #
 # I2C Hardware Bus support
@@ -1319,7 +1671,7 @@ CONFIG_GPIO_DEVRES=y
 CONFIG_GPIOLIB=y
 CONFIG_OF_GPIO=y
 # CONFIG_DEBUG_GPIO is not set
-# CONFIG_GPIO_SYSFS is not set
+CONFIG_GPIO_SYSFS=y
 
 #
 # Memory mapped GPIO drivers:
@@ -1386,7 +1738,7 @@ CONFIG_HWMON=y
 # CONFIG_SENSORS_ADM1025 is not set
 # CONFIG_SENSORS_ADM1026 is not set
 # CONFIG_SENSORS_ADM1029 is not set
-CONFIG_SENSORS_ADM1031=y
+# CONFIG_SENSORS_ADM1031 is not set
 # CONFIG_SENSORS_ADM9240 is not set
 # CONFIG_SENSORS_ADT7310 is not set
 # CONFIG_SENSORS_ADT7410 is not set
@@ -1667,7 +2019,7 @@ CONFIG_USB_EHCI_HCD=y
 # CONFIG_USB_EHCI_TT_NEWSCHED is not set
 CONFIG_USB_EHCI_PCI=y
 CONFIG_USB_EHCI_BIG_ENDIAN_MMIO=y
-# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+CONFIG_USB_EHCI_HCD_PLATFORM=y
 CONFIG_USB_OCTEON_HCD=y
 CONFIG_USB_OCTEON_EHCI=y
 # CONFIG_USB_OXU210HP_HCD is not set
@@ -1690,7 +2042,7 @@ CONFIG_USB_OCTEON2_COMMON=y
 #
 # CONFIG_USB_ACM is not set
 # CONFIG_USB_PRINTER is not set
-# CONFIG_USB_WDM is not set
+CONFIG_USB_WDM=m
 # CONFIG_USB_TMC is not set
 
 #
@@ -1729,7 +2081,63 @@ CONFIG_USB_DWC3_HOST=y
 #
 # USB port drivers
 #
-# CONFIG_USB_SERIAL is not set
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_ZTE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
 
 #
 # USB Miscellaneous drivers
@@ -1756,6 +2164,7 @@ CONFIG_USB_DWC3_HOST=y
 # CONFIG_USB_YUREX is not set
 # CONFIG_USB_EZUSB_FX2 is not set
 # CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_ATM is not set
 # CONFIG_USB_PHY is not set
 # CONFIG_USB_GADGET is not set
 # CONFIG_UWB is not set
@@ -1812,7 +2221,20 @@ CONFIG_LEDS_CLASS=y
 #
 # LED Triggers
 #
-# CONFIG_LEDS_TRIGGERS is not set
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
 # CONFIG_ACCESSIBILITY is not set
 # CONFIG_INFINIBAND is not set
 CONFIG_EDAC_SUPPORT=y
@@ -1921,11 +2343,19 @@ CONFIG_RTC_DRV_DS1307=y
 CONFIG_STAGING=y
 # CONFIG_ET131X is not set
 # CONFIG_USBIP_CORE is not set
+# CONFIG_PRISM2_USB is not set
 # CONFIG_ECHO is not set
 # CONFIG_COMEDI is not set
 # CONFIG_ASUS_OLED is not set
+# CONFIG_R8187SE is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
 # CONFIG_RTS5139 is not set
 # CONFIG_TRANZPORT is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
 # CONFIG_DX_SEP is not set
 # CONFIG_CRYSTALHD is not set
 # CONFIG_USB_ENESTORAGE is not set
@@ -1945,6 +2375,7 @@ CONFIG_STAGING=y
 # CONFIG_ANDROID is not set
 # CONFIG_USB_WPAN_HCD is not set
 # CONFIG_WIMAX_GDM72XX is not set
+# CONFIG_CSR_WIFI is not set
 # CONFIG_NET_VENDOR_SILICOM is not set
 # CONFIG_CED1401 is not set
 # CONFIG_DGRP is not set
@@ -2003,13 +2434,13 @@ CONFIG_EXT3_FS_XATTR=y
 CONFIG_EXT3_FS_POSIX_ACL=y
 # CONFIG_EXT3_FS_SECURITY is not set
 CONFIG_EXT4_FS=y
-CONFIG_EXT4_FS_POSIX_ACL=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
 # CONFIG_EXT4_FS_SECURITY is not set
 # CONFIG_EXT4_DEBUG is not set
 CONFIG_JBD=y
 # CONFIG_JBD_DEBUG is not set
 CONFIG_JBD2=y
-# CONFIG_JBD2_DEBUG is not set
+CONFIG_JBD2_DEBUG=y
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
@@ -2018,7 +2449,6 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_BTRFS_FS is not set
 # CONFIG_NILFS2_FS is not set
 CONFIG_FS_POSIX_ACL=y
-CONFIG_EXPORTFS=y
 CONFIG_FILE_LOCKING=y
 CONFIG_FSNOTIFY=y
 CONFIG_DNOTIFY=y
@@ -2038,9 +2468,7 @@ CONFIG_INOTIFY_USER=y
 #
 # CD-ROM/DVD Filesystems
 #
-CONFIG_ISO9660_FS=y
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
+# CONFIG_ISO9660_FS is not set
 # CONFIG_UDF_FS is not set
 
 #
@@ -2051,7 +2479,9 @@ CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
 
 #
 # Pseudo filesystems
@@ -2059,7 +2489,7 @@ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_PAGE_MONITOR is not set
 CONFIG_SYSFS=y
 CONFIG_TMPFS=y
 # CONFIG_TMPFS_POSIX_ACL is not set
@@ -2077,7 +2507,17 @@ CONFIG_MISC_FILESYSTEMS=y
 # CONFIG_BFS_FS is not set
 # CONFIG_EFS_FS is not set
 # CONFIG_YAFFS_FS is not set
-# CONFIG_JFFS2_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
 CONFIG_UBIFS_FS=y
 CONFIG_UBIFS_FS_ADVANCED_COMPR=y
 CONFIG_UBIFS_FS_LZO=y
@@ -2104,29 +2544,7 @@ CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
 # CONFIG_F2FS_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V2=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-CONFIG_NFS_V4=y
-# CONFIG_NFS_SWAP is not set
-# CONFIG_NFS_V4_1 is not set
-CONFIG_ROOT_NFS=y
-# CONFIG_NFS_USE_LEGACY_DNS is not set
-CONFIG_NFS_USE_KERNEL_DNS=y
-# CONFIG_NFSD is not set
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-CONFIG_SUNRPC_GSS=y
-# CONFIG_SUNRPC_DEBUG is not set
-# CONFIG_CEPH_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
 CONFIG_NLS=y
 CONFIG_NLS_DEFAULT="iso8859-1"
 CONFIG_NLS_CODEPAGE_437=y
@@ -2183,7 +2601,7 @@ CONFIG_NLS_ISO8859_1=y
 # Kernel hacking
 #
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-# CONFIG_PRINTK_TIME is not set
+CONFIG_PRINTK_TIME=y
 CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
 CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
@@ -2205,8 +2623,7 @@ CONFIG_PANIC_ON_OOPS_VALUE=0
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_OBJECTS is not set
-# CONFIG_SLUB_DEBUG_ON is not set
-# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
 CONFIG_HAVE_DEBUG_KMEMLEAK=y
 # CONFIG_DEBUG_KMEMLEAK is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
@@ -2350,7 +2767,7 @@ CONFIG_CRYPTO_AUTHENC=m
 CONFIG_CRYPTO_CBC=y
 # CONFIG_CRYPTO_CTR is not set
 # CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
+CONFIG_CRYPTO_ECB=y
 # CONFIG_CRYPTO_LRW is not set
 # CONFIG_CRYPTO_PCBC is not set
 # CONFIG_CRYPTO_XTS is not set
@@ -2371,7 +2788,7 @@ CONFIG_CRYPTO_CRC32C=y
 # CONFIG_CRYPTO_GHASH is not set
 # CONFIG_CRYPTO_MD4 is not set
 CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
+CONFIG_CRYPTO_MICHAEL_MIC=y
 # CONFIG_CRYPTO_RMD128 is not set
 # CONFIG_CRYPTO_RMD160 is not set
 # CONFIG_CRYPTO_RMD256 is not set
@@ -2387,7 +2804,7 @@ CONFIG_CRYPTO_SHA1=m
 #
 CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
+CONFIG_CRYPTO_ARC4=y
 CONFIG_CRYPTO_BLOWFISH=m
 CONFIG_CRYPTO_BLOWFISH_COMMON=m
 # CONFIG_CRYPTO_CAMELLIA is not set
@@ -2413,8 +2830,9 @@ CONFIG_CRYPTO_LZO=y
 # Random Number Generation
 #
 CONFIG_CRYPTO_ANSI_CPRNG=m
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_USER_API=m
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
 CONFIG_CRYPTO_HW=y
 # CONFIG_ASYMMETRIC_KEY_TYPE is not set
 # CONFIG_BINARY_PRINTF is not set
@@ -2426,7 +2844,7 @@ CONFIG_BITREVERSE=y
 CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
 CONFIG_GENERIC_PCI_IOMAP=y
 CONFIG_GENERIC_IO=y
-# CONFIG_CRC_CCITT is not set
+CONFIG_CRC_CCITT=m
 CONFIG_CRC16=y
 # CONFIG_CRC_T10DIF is not set
 # CONFIG_CRC_ITU_T is not set
@@ -2437,7 +2855,7 @@ CONFIG_CRC32_SLICEBY8=y
 # CONFIG_CRC32_SARWATE is not set
 # CONFIG_CRC32_BIT is not set
 # CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
+CONFIG_LIBCRC32C=y
 # CONFIG_CRC8 is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
@@ -2445,8 +2863,11 @@ CONFIG_LZO_COMPRESS=y
 CONFIG_LZO_DECOMPRESS=y
 # CONFIG_XZ_DEC is not set
 # CONFIG_XZ_DEC_BCJ is not set
-CONFIG_DECOMPRESS_GZIP=y
 CONFIG_BCH=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
 CONFIG_HAS_DMA=y
@@ -2458,7 +2879,5 @@ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE
 # CONFIG_CORDIC is not set
 # CONFIG_DDR is not set
 CONFIG_LIBFDT=y
-CONFIG_OID_REGISTRY=y
 CONFIG_HAVE_KVM=y
-CONFIG_VIRTUALIZATION=y
-# CONFIG_KVM_MIPS_VZ is not set
+# CONFIG_VIRTUALIZATION is not set
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c
--- OCTEON-SDK.orig/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c	2015-11-21 09:53:01.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/cavium-octeon/executive/cvmx-helper-sgmii.c	2017-02-14 12:04:47.489536926 +0800
@@ -185,6 +185,16 @@ static int __cvmx_helper_sgmii_hardware_
 	if (!cvmx_helper_is_port_valid(interface, index))
 		return 0;
 
+        //liteon+
+        //fixed sgmii0/1 disconnection after ifconfig eth0/1 up->down->up 
+	    control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+        control_reg.s.an_en = 0;
+        control_reg.s.pwr_dn = 1;
+        cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface), control_reg.u64);
+        mdelay(10);
+        //liteon-
+
+
 	/*
 	 * Take PCS through a reset sequence.
 	 * PCS*_MR*_CONTROL_REG[PWR_DN] should be cleared to zero.
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/arch/mips/cavium-octeon/Kconfig OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/cavium-octeon/Kconfig
--- OCTEON-SDK.orig/linux/kernel/linux/arch/mips/cavium-octeon/Kconfig	2015-11-21 09:53:01.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/cavium-octeon/Kconfig	2017-02-14 12:04:53.014091561 +0800
@@ -269,4 +269,24 @@ config OCTEON_ERROR_INJECTOR
 	  Used to test hardware error reporting.  Should never be used
 	  in a normal running system.
 
+config CAVIUM_OCTEON_IPFWD_OFFLOAD
+	bool "Enable Cavium Octeon ip-offload module"
+	default "n"
+	help
+	  This enables Cavium Octeon ip-offload module.
+
+config CAVIUM_OCTEON_IPFWD_OFFLOAD
+	bool "Enable Cavium Octeon ip-offload module"
+	default "n"
+	help
+	  This enables Cavium Octeon ip-offload module.
+
+config CAVIUM_OCTEON_IPSEC
+	bool "Enable enhancements to the IPSec stack to allow procotol offload."
+	default "n"
+	help
+	  This enables enhancements to the IPSec stack to allow some of the
+	    processing required for IPSec to be performed on another processor
+	    which must be running the ipsec-filter application.
+
 endif #CAVIUM_OCTEON_SOC
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/arch/mips/cavium-octeon/octeon-nand.c OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/cavium-octeon/octeon-nand.c
--- OCTEON-SDK.orig/linux/kernel/linux/arch/mips/cavium-octeon/octeon-nand.c	2017-02-14 11:55:06.484532823 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/cavium-octeon/octeon-nand.c	2017-02-14 12:05:03.146661637 +0800
@@ -8,7 +8,7 @@
  *
  * Copyright (C) 2008 - 2012 Cavium, Inc.
  */
-
+#define WM_DEBUG 1
 #include <asm/octeon/cvmx.h>
 #include <asm/octeon/cvmx-nand.h>
 #include <asm/octeon/octeon.h>
@@ -1271,7 +1271,9 @@ static int octeon_nand_probe(struct plat
 	int active_chips = 0;
 	char *name;
 	int chip_num = 0; /* Count of detected chips, used for device naming */
-
+#if 1 //def WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif	
 	DEV_DBG(DEBUG_INIT, &pdev->dev, "called\n");
 
 	for_each_child_of_node(pdev->dev.of_node, child_node) {
@@ -1283,7 +1285,8 @@ static int octeon_nand_probe(struct plat
 	}
 	if (!active_chips)
 		return -ENODEV;
-
+	
+	pr_info("[%s][%d]active_chips 0x%x\n", __func__, __LINE__, active_chips);
 #if 0
 	/*
 	 * Optionally set defaults to be used for NAND chips that aren't
@@ -1351,7 +1354,9 @@ static int octeon_nand_probe(struct plat
 			dev_err(&pdev->dev, "Failed to initialize BCH for NAND\n");
 			return -ENXIO;
 		}
-
+		
+		pr_info("[%s][%d]\n", __func__, __LINE__);
+	
 		if (nand_scan(&priv->mtd, 1) != 0) {
 			dev_err(&pdev->dev, "NAND scan failed\n");
 			return -ENXIO;
@@ -1372,6 +1377,11 @@ static int octeon_nand_probe(struct plat
 		priv->mtd.name = name;
 		priv->mtd.dev.parent = &pdev->dev;
 
+#ifdef WM_DEBUG
+		printk("[%s][%d]numeraseregions %d\n", __func__, __LINE__, priv->mtd.numeraseregions);
+		pr_info("[%s][%d]numeraseregions %d\n", __func__, __LINE__, priv->mtd.numeraseregions);
+		priv->mtd.numeraseregions = 0;
+#endif		
 		mtd_device_parse_register(&priv->mtd, part_probes,
 					  NULL, NULL, 0);
 		octeon_nand_open_mtd[chip] = priv;
@@ -1419,6 +1429,9 @@ static struct platform_driver octeon_nan
 
 static int __init octeon_nand_driver_init(void)
 {
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif	
 	return platform_driver_register(&octeon_nand_driver);
 }
 /*
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/arch/mips/include/asm/octeon/octeon-ethernet-user.h OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/include/asm/octeon/octeon-ethernet-user.h
--- OCTEON-SDK.orig/linux/kernel/linux/arch/mips/include/asm/octeon/octeon-ethernet-user.h	2015-11-21 09:53:01.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/arch/mips/include/asm/octeon/octeon-ethernet-user.h	2017-02-14 12:05:19.931230440 +0800
@@ -95,10 +95,31 @@ typedef cvm_oct_callback_result_t (*cvm_
 							struct sk_buff *skb);
 
 extern struct net_device *cvm_oct_register_callback(const char *, cvm_oct_callback_t);
+extern struct net_device *is_oct_dev(const char *device_name);
 
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD 
+extern int cvm_oct_transmit_qos(struct net_device *dev,
+				void *work_queue_entry,
+				int do_free,
+				int qos);
+
+extern int cvm_oct_transmit_qos_not_free(struct net_device *dev,
+					 void *work_queue_entry,
+					 struct sk_buff *skb);
+
+extern struct net_device *octeon3_register_callback(const char	*device_name,
+						    cvm_oct_callback_t	callback);
+
+extern struct net_device *octeon3_is_oct_dev(const char *device_name);
+
+extern int octeon3_transmit_qos(struct net_device *dev, 
+				void *work, 
+				int do_free,
+				int qos);
+#else 
 extern int cvm_oct_transmit_qos(struct net_device *dev, void *work_queue_entry,
 			 int do_free, int qos);
-
+#endif
 #endif /* __KERNEL__ */
 
 #endif
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/i2c/i2c-core.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/i2c/i2c-core.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/i2c/i2c-core.c	2015-11-21 09:53:29.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/i2c/i2c-core.c	2017-02-14 12:05:47.750352431 +0800
@@ -1624,6 +1624,9 @@ static void i2c_perform_op_wait(struct i
 	int ret = 0;
 
 	pr_debug("i2c_perform_op_wait %p %p\n", adap, entry);
+	//liteon add >>
+	i2c_init_entry(adap, entry);
+	//liteon add <<
 	entry->handler = i2c_wait_done;
 
 	spin_lock_irqsave(&adap->q_lock, flags);
@@ -1678,7 +1681,9 @@ static void i2c_transfer_entry(struct i2
 			(entry->i2c.msgs[ret].flags & I2C_M_RECV_LEN) ? "+" : "");
 	}
 #endif
-	i2c_init_entry(adap, entry);
+	//liteon mark>>
+	//i2c_init_entry(adap, entry);
+	//liteon mark<<
 	if (adap->algo->master_start)
 		i2c_perform_op_wait(adap, entry);
 	else if (adap->algo->master_xfer) {
@@ -2496,9 +2501,13 @@ s32 i2c_smbus_xfer(struct i2c_adapter *a
 	entry->smbus.data = data;
 	entry->complete = NULL;
 	entry->handler = NULL;
-	i2c_init_entry(adapter, entry);
 	entry->result = -EOPNOTSUPP;
 
+	//liteon mark >>
+	//i2c_init_entry(adapter, entry);
+	//liteon mark <<
+
+
 	if (algo->smbus_start) {
 		i2c_perform_op_wait(adapter, entry);
 	} else if (algo->smbus_xfer) {
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/mtd/mtdcore.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/mtd/mtdcore.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/mtd/mtdcore.c	2015-11-21 09:53:10.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/mtd/mtdcore.c	2017-02-14 12:06:10.125663063 +0800
@@ -20,7 +20,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  */
-
+#define WM_DEBUG
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/ptrace.h>
@@ -408,6 +408,11 @@ int add_mtd_device(struct mtd_info *mtd)
 	   of this try_ nonsense, and no bitching about it
 	   either. :) */
 	__module_get(THIS_MODULE);
+
+#ifdef WM_DEBUG
+	printk("[%s][%d]index %d name %s numeraseregions %d\n", __func__, __LINE__, 
+				mtd->index, mtd->name, mtd->numeraseregions);
+#endif	
 	return 0;
 
 fail_added:
@@ -629,6 +634,11 @@ struct mtd_info *get_mtd_device(struct m
 		goto out;
 	}
 
+#ifdef WM_DEBUG
+	if(mtd != NULL)
+	printk("[%s][%d]num %d index %d numeraseregions %d\n", __func__, __LINE__, 
+		num, mtd->index, mtd->numeraseregions);
+#endif
 	err = __get_mtd_device(ret);
 	if (err)
 		ret = ERR_PTR(err);
@@ -683,7 +693,10 @@ struct mtd_info *get_mtd_device_nm(const
 
 	if (!mtd)
 		goto out_unlock;
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]index %d numeraseregions %d\n", __func__, __LINE__, 
+		 mtd->index, mtd->numeraseregions);
+#endif
 	err = __get_mtd_device(mtd);
 	if (err)
 		goto out_unlock;
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/mtd/ubi/build.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/mtd/ubi/build.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/mtd/ubi/build.c	2015-11-21 09:53:10.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/mtd/ubi/build.c	2017-02-14 12:06:00.383433314 +0800
@@ -28,7 +28,7 @@
  * specified, UBI does not attach any MTD device, but it is possible to do
  * later using the "UBI control device".
  */
-
+#define WM_DEBUG 1
 #include <linux/err.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
@@ -501,7 +501,9 @@ static int uif_init(struct ubi_device *u
 {
 	int i, err;
 	dev_t dev;
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
 	*ref = 0;
 	sprintf(ubi->ubi_name, UBI_NAME_STR "%d", ubi->ubi_num);
 
@@ -648,7 +650,7 @@ static int io_init(struct ubi_device *ub
 		 * guess we should just pick the largest region. But this is
 		 * not implemented.
 		 */
-		ubi_err("multiple regions, not implemented");
+		ubi_err("multiple regions %d, not implemented", ubi->mtd->numeraseregions);
 		return -EINVAL;
 	}
 
@@ -868,6 +870,10 @@ int ubi_attach_mtd_dev(struct mtd_info *
 	struct ubi_device *ubi;
 	int i, err, ref = 0;
 
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
+
 	if (max_beb_per1024 < 0 || max_beb_per1024 > MAX_MTD_UBI_BEB_LIMIT)
 		return -EINVAL;
 
@@ -969,7 +975,9 @@ int ubi_attach_mtd_dev(struct mtd_info *
 	init_rwsem(&ubi->fm_sem);
 
 	ubi_msg("attaching mtd%d to ubi%d", mtd->index, ubi_num);
-
+#ifdef WM_DEBUG
+	printk("[%s][%d] mtd%d to ubi%d\n", __func__, __LINE__,  mtd->index, ubi_num);
+#endif
 	err = io_init(ubi, max_beb_per1024);
 	if (err)
 		goto out_free;
@@ -996,7 +1004,9 @@ int ubi_attach_mtd_dev(struct mtd_info *
 		if (err)
 			goto out_detach;
 	}
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
 	err = uif_init(ubi, &ref);
 	if (err)
 		goto out_detach;
@@ -1012,7 +1022,9 @@ int ubi_attach_mtd_dev(struct mtd_info *
 			err);
 		goto out_debugfs;
 	}
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
 	ubi_msg("attached mtd%d (name \"%s\", size %llu MiB) to ubi%d",
 		mtd->index, mtd->name, ubi->flash_size >> 20, ubi_num);
 	ubi_msg("PEB size: %d bytes (%d KiB), LEB size: %d bytes",
@@ -1219,7 +1231,9 @@ static int __init ubi_init(void)
 		ubi_err("too many MTD devices, maximum is %d", UBI_MAX_DEVICES);
 		return -EINVAL;
 	}
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]mtd_devs %d\n", __func__, __LINE__, mtd_devs);
+#endif
 	/* Create base sysfs directory and sysfs files */
 	ubi_class = class_create(THIS_MODULE, UBI_NAME_STR);
 	if (IS_ERR(ubi_class)) {
@@ -1227,7 +1241,9 @@ static int __init ubi_init(void)
 		ubi_err("cannot create UBI class");
 		goto out;
 	}
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
 	err = class_create_file(ubi_class, &ubi_version);
 	if (err) {
 		ubi_err("cannot create sysfs file");
@@ -1239,25 +1255,33 @@ static int __init ubi_init(void)
 		ubi_err("cannot register device");
 		goto out_version;
 	}
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
 	ubi_wl_entry_slab = kmem_cache_create("ubi_wl_entry_slab",
 					      sizeof(struct ubi_wl_entry),
 					      0, 0, NULL);
 	if (!ubi_wl_entry_slab)
 		goto out_dev_unreg;
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
 	err = ubi_debugfs_init();
 	if (err)
 		goto out_slab;
 
-
+#ifdef WM_DEBUG
+	printk("[%s][%d]\n", __func__, __LINE__);
+#endif
 	/* Attach MTD devices */
 	for (i = 0; i < mtd_devs; i++) {
 		struct mtd_dev_param *p = &mtd_dev_param[i];
 		struct mtd_info *mtd;
 
 		cond_resched();
-
+#ifdef WM_DEBUG
+		printk("[%s][%d]i %d, p->name %s\n", __func__, __LINE__, i, p->name);
+#endif
 		mtd = open_mtd_device(p->name);
 		if (IS_ERR(mtd)) {
 			err = PTR_ERR(mtd);
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet.c	2017-02-14 11:55:06.611532929 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet.c	2017-02-14 12:06:29.272501832 +0800
@@ -56,6 +56,10 @@
 #include <asm/octeon/cvmx-gmxx-defs.h>
 #include <asm/octeon/cvmx-smix-defs.h>
 
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+#include "ipfwd_config.h"
+#endif
+
 int rx_cpu_factor = 8;
 module_param(rx_cpu_factor, int, S_IRUGO | S_IWUSR | S_IWGRP);
 MODULE_PARM_DESC(rx_cpu_factor, "Control how many CPUs are used for packet reception.\n"
@@ -65,7 +69,7 @@ int octeon_recycle_tx = REUSE_SKBUFFS_WI
 module_param_named(recycle_tx, octeon_recycle_tx, int, S_IRUGO | S_IWUSR | S_IWGRP);
 MODULE_PARM_DESC(recycle_tx, "Allow hardware SKB recycling.");
 
-int num_packet_buffers = 1024;
+int num_packet_buffers = 4096;
 module_param(num_packet_buffers, int, 0444);
 MODULE_PARM_DESC(num_packet_buffers, "\n"
 	"\tNumber of packet buffers to allocate and store in the\n"
@@ -100,6 +104,24 @@ static int disable_lockless_pko;
 module_param(disable_lockless_pko, int, S_IRUGO);
 MODULE_PARM_DESC(disable_lockless_pko, "Disable lockless PKO access (use locking for queues instead).");
 
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD) && defined(IPFWD_OUTPUT_QOS)
+/* internal ports count for each port in a interface */
+int iport_count = 1;
+#include <asm/octeon/cvmx-helper.h>
+CVMX_SHARED void ipfwd_pko_queue_priority(int ipd_port, uint8_t *priorities)
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		priorities[i] = CVMX_PKO_QUEUE_STATIC_PRIORITY;
+}
+
+/* pko queue count for each port in a interface */
+int queues_count = PKO_QUEUES_PER_PORT;
+#else
+/* pko queue count for each port in a interface */
+int queues_count = 1;
+#endif
 /* packet pool */
 int packet_pool = 0;
 /* wqe pool */
@@ -234,6 +256,41 @@ static bool cvm_oct_pko_lockless(void)
 	return queues <= cvm_oct_get_total_pko_queues();
 }
 
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD) && defined(IPFWD_OUTPUT_QOS)
+static void cvm_oct_set_pko_multiqueue(void)
+{
+	int interface, num_interfaces, rv;
+
+	num_interfaces = cvmx_helper_get_number_of_interfaces();
+	for (interface = 0; interface < num_interfaces; interface++) {
+		int num_ports, port;
+		cvmx_helper_interface_mode_t imode = cvmx_helper_interface_get_mode(interface);
+
+		num_ports = cvmx_helper_interface_enumerate(interface);
+		for (port = 0; port < num_ports; port++) {
+			if (!cvmx_helper_is_port_valid(interface, port))
+				continue;
+			switch (imode) {
+			case CVMX_HELPER_INTERFACE_MODE_XAUI:
+			case CVMX_HELPER_INTERFACE_MODE_RXAUI:
+			case CVMX_HELPER_INTERFACE_MODE_SGMII:
+			case CVMX_HELPER_INTERFACE_MODE_QSGMII:
+			case CVMX_HELPER_INTERFACE_MODE_AGL:
+			case CVMX_HELPER_INTERFACE_MODE_RGMII:
+			case CVMX_HELPER_INTERFACE_MODE_GMII:
+			case CVMX_HELPER_INTERFACE_MODE_SPI:
+				rv = cvmx_pko_alloc_iport_and_queues(interface, port, 1, queues_count);
+				WARN(rv, "cvmx_pko_alloc_iport_and_queues failed");
+				if (rv)
+					return;
+				break;
+			default:
+				break;
+			}
+		}
+	}
+}
+#else
 static void cvm_oct_set_pko_multiqueue(void)
 {
 	int interface, num_interfaces, rv;
@@ -268,6 +325,7 @@ static void cvm_oct_set_pko_multiqueue(v
 		}
 	}
 }
+#endif
 
 static int num_devices_extra_wqe;
 #define PER_DEVICE_EXTRA_WQE (MAX_OUT_QUEUE_DEPTH)
@@ -312,6 +370,9 @@ static struct notifier_block cvm_kexec_c
 
 static int cvm_oct_configure_common_hw(void)
 {
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD) && defined(IPFWD_OUTPUT_QOS)
+	cvmx_override_pko_queue_priority = ipfwd_pko_queue_priority;
+#endif
 	/* Setup the FPA */
 	cvmx_fpa1_enable();
 
@@ -414,6 +475,20 @@ struct net_device *cvm_oct_register_call
 }
 EXPORT_SYMBOL(cvm_oct_register_callback);
 
+struct net_device *is_oct_dev(const char *device_name)
+{
+        struct octeon_ethernet *priv;
+
+        list_for_each_entry(priv, &cvm_oct_list, list) {
+                if (strcmp(device_name, priv->netdev->name) == 0) {
+                        wmb();
+                        return priv->netdev;
+                }
+        }
+        return NULL;
+}
+EXPORT_SYMBOL(is_oct_dev);
+
 /**
  * cvm_oct_free_work- Free a work queue entry
  *
@@ -801,25 +876,6 @@ static struct device_node *cvm_oct_node_
 	return np;
 }
 
-static bool cvm_is_phy_sgmii(struct device_node *node)
-{
-	struct device_node	*phy_node;
-	const char		*p;
-	bool			rc = false;
-
-	phy_node = of_parse_phandle(node, "phy-handle", 0);
-	if (phy_node == NULL)
-		return rc;
-
-	if (!of_property_read_string(phy_node, "vitesse,phy-mode", &p)) {
-		if (!strcmp(p, "sgmii"))
-			rc = true;
-	}
-	of_node_put(phy_node);
-
-	return rc;
-}
-
 static int cvm_oct_get_port_status(struct device_node *pip)
 {
 	int i, j;
@@ -862,9 +918,8 @@ static int cvm_oct_get_port_status(struc
 				cvmx_helper_set_mac_phy_mode(i, j, false);
 				cvmx_helper_set_1000x_mode(i, j, false);
 				if (port_node) {
-					if ((of_get_property(port_node,
-					     "cavium,sgmii-mac-phy-mode", NULL) != NULL) ||
-					    cvm_is_phy_sgmii(port_node))
+					if (of_get_property(port_node, 
+					    "cavium,sgmii-mac-phy-mode", NULL) != NULL)
 						cvmx_helper_set_mac_phy_mode(i, j, true);
 					if (of_get_property(port_node, 
 					    "cavium,sgmii-mac-1000x-mode", NULL) 
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-defines.h OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-defines.h
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-defines.h	2015-11-21 09:53:13.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-defines.h	2017-02-14 12:06:38.178996737 +0800
@@ -56,7 +56,7 @@
 
 /* FPA defines */
 #define FPA_WQE_POOL_SIZE (1 * CVMX_CACHE_LINE_SIZE)
-#define FPA_PACKET_POOL_SIZE (16 * CVMX_CACHE_LINE_SIZE)
+#define FPA_PACKET_POOL_SIZE (32 * CVMX_CACHE_LINE_SIZE)
 #define FPA_OUTPUT_BUFFER_POOL_SIZE (8 * CVMX_CACHE_LINE_SIZE)
 
 /* TODO: replace this */
@@ -93,6 +93,7 @@
 
 #define FAU_NUM_PACKET_BUFFERS_TO_FREE (FAU_REG_END - sizeof(u32))
 
+/*TODO: Change this to number valid both for 78xx and other */
 #define TOTAL_NUMBER_OF_PORTS       (CVMX_PIP_NUM_INPUT_PORTS+1)
 
 
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-mdio.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-mdio.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-mdio.c	2015-11-21 09:53:13.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-mdio.c	2017-02-14 12:06:44.746565473 +0800
@@ -414,6 +414,50 @@ void cvm_oct_set_carrier(struct octeon_e
 			netif_carrier_off(priv->netdev);
 	}
 }
+//liteon+
+//force link at switch ic
+static int liteon_sgmii_1G_link(struct net_device *dev)
+{
+  struct octeon_ethernet *priv = netdev_priv(dev);
+  int interface = cvmx_helper_get_interface_num(priv->ipd_port);
+  int index = cvmx_helper_get_interface_index_num(priv->ipd_port);
+  union cvmx_pcsx_mrx_control_reg control_reg;
+  union cvmx_gmxx_prtx_cfg gmxx_prtx_cfg;
+  union cvmx_pcsx_miscx_ctl_reg pcsx_miscx_ctl_reg;
+  //printk(KERN_ERR"liteon_sgmii_1G_link\n");
+  control_reg.u64 = cvmx_read_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface));
+  control_reg.s.an_en = 1;
+  control_reg.s.pwr_dn = 0;
+  if (priv->last_link)
+  {
+      //control_reg.s.pwr_dn = 0;
+      control_reg.s.spdmsb = 1;
+      control_reg.s.spdlsb = 0;
+      control_reg.s.dup = 1;
+
+      gmxx_prtx_cfg.u64 = cvmx_read_csr(CVMX_GMXX_PRTX_CFG(index, interface));
+      gmxx_prtx_cfg.s.speed = 1;
+      gmxx_prtx_cfg.s.speed_msb = 0;
+      gmxx_prtx_cfg.s.slottime = 1;
+      cvmx_write_csr(CVMX_GMXX_PRTX_CFG(index, interface), gmxx_prtx_cfg.u64);   
+
+      pcsx_miscx_ctl_reg.u64 = cvmx_read_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface));
+      pcsx_miscx_ctl_reg.s.samp_pt = 1;
+      cvmx_write_csr(CVMX_PCSX_MISCX_CTL_REG(index, interface),pcsx_miscx_ctl_reg.u64);
+
+  }
+  else
+  {
+      control_reg.s.pwr_dn = 1;
+      control_reg.s.spdmsb = 1;
+      control_reg.s.spdlsb = 0;
+      control_reg.s.dup = 1;
+  }
+  cvmx_write_csr(CVMX_PCSX_MRX_CONTROL_REG(index, interface), control_reg.u64);
+
+  return 0;
+}
+//liteon-
 
 void cvm_oct_adjust_link(struct net_device *dev)
 {
@@ -433,6 +477,12 @@ void cvm_oct_adjust_link(struct net_devi
 			priv->link_change(priv, link_info);
 
 		cvm_oct_note_carrier(priv, link_info);
+        //liteon+
+        if (PHY_QCA_SWITCH & priv->phydev->drv->flags)
+        {
+           liteon_sgmii_1G_link(dev); 
+        }
+        //liteon-
 	}
 }
 
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-napi.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-napi.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-napi.c	2015-11-21 09:53:13.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-napi.c	2017-02-14 12:06:50.097378701 +0800
@@ -147,7 +147,9 @@ static int CVM_OCT_NAPI_POLL(struct napi
 			    cores_in_use < core_state.baseline_cores)
 				cvm_oct_enable_one_cpu();
 		}
-		rx_count++;
+#ifndef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+					rx_count++;
+#endif
 
 		/* If WORD2[SOFTWARE] then this WQE is a complete for
 		 * a TX packet.
@@ -409,9 +411,15 @@ static int CVM_OCT_NAPI_POLL(struct napi
 						/* Interceptor took our packet */
 						break;
 					}
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+					rx_count++;
+#endif
 				} else {
 					netif_receive_skb(skb);
 					callback_result = CVM_OCT_PASS;
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+					rx_count++;
+#endif
 				}
 			} else {
 				/* Drop any packet received for a device that isn't up */
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-tx.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-tx.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-tx.c	2015-11-21 09:53:13.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-tx.c	2017-02-14 12:06:55.485823939 +0800
@@ -50,6 +50,10 @@
 
 #include <asm/octeon/cvmx-gmxx-defs.h>
 
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+#include "ipfwd_config.h"
+#endif
+
 /*
  * You can define GET_SKBUFF_QOS() to override how the skbuff output
  * function determines which output queue is used. The default
@@ -58,8 +62,12 @@
  * GET_SKBUFF_QOS as: #define GET_SKBUFF_QOS(skb) ((skb)->priority)
  */
 #ifndef GET_SKBUFF_QOS
+#if CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD && IPFWD_OUTPUT_QOS
+#define GET_SKBUFF_QOS(skb) ((skb)->cvm_info.qos_level)
+#else
 #define GET_SKBUFF_QOS(skb) 0
 #endif
+#endif
 
 static bool cvm_oct_skb_ok_for_reuse(struct sk_buff *skb)
 {
@@ -201,7 +209,11 @@ int cvm_oct_transmit_qos(struct net_devi
 
 	/* Build the PKO command */
 	pko_command.u64 = 0;
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+	pko_command.s.n2 = 0; /* pollute L2 with the outgoing packet */
+#else 
 	pko_command.s.n2 = 1; /* Don't pollute L2 with the outgoing packet */
+#endif
 	pko_command.s.dontfree = !do_free;
 	pko_command.s.segs = work->word2.s.bufs;
 	pko_command.s.total_bytes = work->word1.len;
@@ -210,7 +222,11 @@ int cvm_oct_transmit_qos(struct net_devi
 	if (unlikely(work->word2.s.not_IP || work->word2.s.IP_exc))
 		pko_command.s.ipoffp1 = 0;
 	else
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+		pko_command.s.ipoffp1 = sizeof(struct ethhdr) + 1 + cvmx_wqe_get_unused8(work);
+#else
 		pko_command.s.ipoffp1 = sizeof(struct ethhdr) + 1;
+#endif
 
 	/* Send the packet to the output queue */
 	if (unlikely(cvmx_hwpko_send_packet_finish_pkoid(priv->pko_port, priv->tx_queue[qos].queue, pko_command, hw_buffer, lock_type))) {
@@ -230,3 +246,141 @@ int cvm_oct_transmit_qos(struct net_devi
 	return dropped;
 }
 EXPORT_SYMBOL(cvm_oct_transmit_qos);
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+/**
+ * cvm_oct_transmit_qos_not_free - transmit a work queue entry out of the ethernet port.
+ *
+ * Both the work queue entry and the packet data can optionally be
+ * freed. The work will be freed on error as well.
+ *
+ * @dev: Device to transmit out.
+ * @work_queue_entry: Work queue entry to send
+ * @skb: socket buffer
+ * @qos: Index into the queues for this port to transmit on. This is
+ *       used to implement QoS if their are multiple queues per
+ *       port. This parameter must be between 0 and the number of
+ *       queues per port minus 1. Values outside of this range will be
+ *       change to zero.
+ *
+ * Returns Zero on success, negative on failure.
+ */
+int cvm_oct_transmit_qos_not_free(struct net_device *dev,
+			 	void *work_queue_entry,
+			 	struct sk_buff *skb)
+{
+	unsigned long			flags;
+	cvmx_buf_ptr_t			hw_buffer;
+	cvmx_pko_command_word0_t	pko_command;
+	int				dropped;
+	struct octeon_ethernet		*priv = netdev_priv(dev);
+	cvmx_wqe_t			*work = work_queue_entry;
+	cvmx_wqe_t			*rcv_work = NULL;
+	cvmx_pko_lock_t lock_type;
+	u64 word2;
+	int qos;
+
+	if (!(dev->flags & IFF_UP)) {
+		netdev_err(dev, "Error: Device not up\n");
+		if (work)
+			cvm_oct_free_work(work);
+		return -1;
+	}
+
+	if (priv->tx_lockless) {
+		qos = cvmx_get_core_num();
+		lock_type = CVMX_PKO_LOCK_NONE;
+	} else {
+		/*
+	 	* The check on CVMX_PKO_QUEUES_PER_PORT_* is designed to
+	 	* completely remove "qos" in the event neither interface
+	 	* supports multiple queues per port.
+	 	*/
+		if (priv->tx_multiple_queues) {
+			qos = GET_SKBUFF_QOS(skb);
+			if (qos <= 0)
+				qos = 0;
+			else if (qos >= priv->num_tx_queues)
+				qos = 0;
+		} else
+			qos = 0;
+		lock_type = CVMX_PKO_LOCK_CMD_QUEUE;
+	}
+
+	/* Start off assuming no drop */
+	dropped = 0;
+
+	/* Build the PKO buffer pointer */
+	hw_buffer.u64 = 0;
+	hw_buffer.s.addr = virt_to_phys(skb->data);
+	hw_buffer.s.pool = packet_pool;
+	hw_buffer.s.size = FPA_PACKET_POOL_SIZE;
+	hw_buffer.s.back = work->packet_ptr.s.back;
+
+	/* Build the PKO command */
+	pko_command.u64 = 0;
+	pko_command.s.n2 = 0; /* pollute L2 with the outgoing packet */
+	pko_command.s.dontfree = 1;
+	pko_command.s.segs = work->word2.s.bufs;
+	pko_command.s.total_bytes = skb->len;
+
+	/* Use fau0 to decrement the number of packets queued */
+	pko_command.s.size0 = CVMX_FAU_OP_SIZE_32;
+	pko_command.s.subone0 = 1;
+
+	/* Check if we can use the hardware checksumming */
+	if (unlikely(work->word2.s.not_IP || work->word2.s.IP_exc))
+		pko_command.s.ipoffp1 = 0;
+	else
+		pko_command.s.ipoffp1 = sizeof(struct ethhdr) + 1 + cvmx_wqe_get_unused8(work);
+		
+	rcv_work = cvmx_fpa_alloc(wqe_pool);
+	if (unlikely(!work)) {
+		netdev_err(dev, "failed to allocate rcv work\n");
+		dropped = -1;
+		goto skip_xmit;
+	}
+
+	pko_command.s.rsp = 1;
+	pko_command.s.wqp = 1;
+
+	pko_command.s.reg0 = 0;
+	rcv_work->word0.u64 = 0;
+	rcv_work->word0.raw.unused = (u8)qos;
+
+	rcv_work->word1.u64 = 0;
+	rcv_work->word1.tag_type = CVMX_POW_TAG_TYPE_NULL;	
+	rcv_work->word1.tag = 0;
+	rcv_work->word2.u64 = 0;
+	rcv_work->word2.s.software = 1;
+	cvmx_wqe_set_grp(rcv_work, pow_receive_group);
+	rcv_work->packet_ptr.u64 = (unsigned long)skb;
+
+	word2 = virt_to_phys(rcv_work);
+
+	local_irq_save(flags);
+
+	cvmx_pko_send_packet_prepare_pkoid(priv->pko_port, priv->tx_queue[qos].queue, lock_type);
+
+	/* Send the packet to the output queue */
+	if (unlikely(cvmx_hwpko_send_packet_finish3_pkoid(priv->pko_port, priv->tx_queue[qos].queue,
+							pko_command, hw_buffer, word2, lock_type))) {
+		printk("%s: Failed to send the packet\n", dev->name);
+		dropped = -1;
+	}
+	local_irq_restore(flags);
+
+skip_xmit:
+	if (unlikely(dropped)) {
+		cvmx_hwfau_atomic_add32(priv->tx_queue[qos].fau, -1);
+		dev_kfree_skb_any(skb);
+		dev->stats.tx_dropped++;
+		if (work)
+			cvmx_fpa_free(work, packet_pool, DONT_WRITEBACK(1));
+		if (rcv_work)
+			cvmx_fpa_free(rcv_work, wqe_pool, DONT_WRITEBACK(1));
+	}
+
+	return dropped;
+}
+EXPORT_SYMBOL(cvm_oct_transmit_qos_not_free);
+#endif
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-xmit.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-xmit.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-xmit.c	2017-02-14 11:55:06.611532929 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ethernet-xmit.c	2017-02-14 12:07:00.941152953 +0800
@@ -155,7 +155,11 @@ CVM_OCT_XMIT
 	pko_command.s.le = 1;
 #endif
 	/* Don't pollute L2 with the outgoing packet */
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+	pko_command.s.n2 = 0;
+#else
 	pko_command.s.n2 = 1;
+#endif
 	pko_command.s.segs = 1;
 	pko_command.s.total_bytes = skb->len;
 	/* Use fau0 to decrement the number of packets queued */
@@ -245,7 +249,7 @@ CVM_OCT_XMIT
 
 	/* Check if we can use the hardware checksumming */
 	if (USE_HW_TCPUDP_CHECKSUM && skb->ip_summed != CHECKSUM_NONE &&
-	    skb->ip_summed != CHECKSUM_UNNECESSARY) {
+		skb->ip_summed != CHECKSUM_UNNECESSARY) {
 		/* Use hardware checksum calc */
 		pko_command.s.ipoffp1 = sizeof(struct ethhdr) + 1;
 		if (unlikely(priv->imode == CVMX_HELPER_INTERFACE_MODE_SRIO))
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ipfwd_config.h OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ipfwd_config.h
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/ipfwd_config.h	1970-01-01 08:00:00.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/ipfwd_config.h	2016-02-09 02:14:38.000000000 +0800
@@ -0,0 +1,5 @@
+/* comment the line to disable output qos */
+#define IPFWD_OUTPUT_QOS	1
+
+/* number of queues per pko port */
+#define PKO_QUEUES_PER_PORT	8
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon3-ethernet.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon3-ethernet.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon3-ethernet.c	2017-02-14 11:55:06.613532931 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon3-ethernet.c	2017-02-14 12:07:10.485638362 +0800
@@ -38,8 +38,6 @@
 #include <linux/if_vlan.h>
 #include <linux/rio_drv.h>
 #include <linux/rio_ids.h>
-#include <linux/net_tstamp.h>
-#include <linux/ptp_clock_kernel.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-helper-cfg.h>
@@ -50,7 +48,6 @@
 #include <asm/octeon/cvmx-fpa3.h>
 #include <asm/octeon/cvmx-srio.h>
 #include <asm/octeon/cvmx-app-config.h>
-#include <asm/octeon/cvmx-bgxx-defs.h>
 
 #include <asm/octeon/cvmx-fpa-defs.h>
 #include <asm/octeon/cvmx-sso-defs.h>
@@ -201,7 +198,6 @@ struct octeon3_ethernet {
 	struct net_device *netdev;
 	enum octeon3_mac_type mac_type;
 	struct octeon3_rx rx_cxt[MAX_RX_CONTEXTS];
-	struct ptp_clock *ptp_clock;
 	int num_rx_cxt;
 	int pki_laura;
 	int pki_pkind;
@@ -211,8 +207,6 @@ struct octeon3_ethernet {
 	int port_index;
 	int rx_buf_count;
 	int tx_complete_grp;
-	int rx_timestamp_hw:1;
-	int tx_timestamp_hw:1;
 	spinlock_t stat_lock;
 	cvm_oct_callback_t intercept_cb;
 	u64 srio_tx_header;
@@ -333,6 +327,12 @@ struct net_device *octeon3_register_call
 
 	rcu_read_lock();
 	for (node = 0; node < MAX_NODES; node++) {
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD)
+		if (!octeon3_eth_node[node].init_done) {
+			/* Node not inited */
+			continue;
+		}
+#endif
 		list_for_each_entry_rcu(priv,
 					&octeon3_eth_node[node].device_list,
 					list) {
@@ -349,6 +349,37 @@ struct net_device *octeon3_register_call
 }
 EXPORT_SYMBOL(octeon3_register_callback);
 
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD)
+/**
+ * octeon3_is_oct_dev:	Register a intercept callback for the named
+ * 				device.
+ *
+ * It returns the net_device structure for the ethernet port.
+ */
+struct net_device *octeon3_is_oct_dev(const char *device_name)
+{
+	struct octeon3_ethernet	*priv;
+	int			node;
+
+	for (node = 0; node < MAX_NODES; node++) {
+		if (!octeon3_eth_node[node].init_done) {
+			/* Node not inited */
+			continue;
+		}
+		list_for_each_entry_rcu(priv,
+					&octeon3_eth_node[node].device_list,
+					list) {
+			if (strcmp(device_name, priv->netdev->name) == 0) {
+				return priv->netdev;
+			}
+		}
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(octeon3_is_oct_dev);
+#endif
+
 /* octeon3_eth_sso_pass1_limit:	Near full TAQ can cause hang. When the TAQ
  *				(Transitory Admission Queue) is near-full, it is
  *				possible for SSO to hang.
@@ -669,42 +700,6 @@ static int octeon3_eth_replenish_all(str
 	return pending;
 }
 
-static ktime_t octeon3_ptp_to_ktime(u64 ptptime)
-{
-	ktime_t ktimebase;
-	u64 ptpbase;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	/* Fill the icache with the code */
-	ktime_get_real();
-	/* Flush all pending operations */
-	mb();
-	/* Read the time and PTP clock as close together as
-	 * possible. It is important that this sequence take the same
-	 * amount of time to reduce jitter
-	 */
-	ktimebase = ktime_get_real();
-	ptpbase = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_HI);
-	local_irq_restore(flags);
-
-	return ktime_sub_ns(ktimebase, ptpbase - ptptime);
-}
-
-static int octeon3_eth_tx_complete_hwtstamp(struct sk_buff *skb)
-{
-	struct skb_shared_hwtstamps	shts;
-	u64				ts;
-
-	ts = *((u64 *)(skb->cb) + 1);
-	memset(&shts, 0, sizeof(shts));
-	shts.hwtstamp = ns_to_ktime(ts);
-	shts.syststamp = octeon3_ptp_to_ktime(ts);
-	skb_tstamp_tx(skb, &shts);
-
-	return 0;
-}
-
 static int octeon3_eth_tx_complete_worker(void *data)
 {
 	union cvmx_sso_grpx_aq_cnt aq_cnt;
@@ -743,9 +738,6 @@ static int octeon3_eth_tx_complete_worke
 				    atomic64_read(&tx_priv->tx_backlog) < MAX_TX_QUEUE_DEPTH)
 					netif_wake_queue(tx_netdev);
 				skb = container_of((void *)work, struct sk_buff, cb);
-				if (unlikely(tx_priv->tx_timestamp_hw) && 
-				    unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))
-					    octeon3_eth_tx_complete_hwtstamp(skb);
 				dev_kfree_skb(skb);
 			}
 
@@ -1222,6 +1214,13 @@ static int octeon3_eth_rx_one(struct oct
 			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
 				/* PKI_BUFLINK_S's are endian-swapped */
 				packet_ptr.u64 = swab64(packet_ptr.u64);
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD)
+				/*
+				 * Store that swapped packet pointer back
+				 * Just in case anyone want to use it later
+				 */
+				*(u64 *)(data - 8) = packet_ptr.u64;
+#endif
 			}
 #endif
 			data = phys_to_virt(packet_ptr.addr);
@@ -1243,17 +1242,6 @@ static int octeon3_eth_rx_one(struct oct
 
 	if (likely(priv->netdev->flags & IFF_UP)) {
 		skb_checksum_none_assert(skb);
-		if (unlikely(priv->rx_timestamp_hw)) {
-			/* The first 8 bytes are the timestamp */
-			u64 ts = *(u64 *)skb->data;
-			struct skb_shared_hwtstamps *shts;
-
-			shts = skb_hwtstamps(skb);
-			shts->hwtstamp = ns_to_ktime(ts);
-			shts->syststamp = octeon3_ptp_to_ktime(ts);
-			__skb_pull(skb, 8);
-		}
-
 		skb->protocol = eth_type_trans(skb, priv->netdev);
 		skb->dev = priv->netdev;
 		if (priv->netdev->features & NETIF_F_RXCSUM) {
@@ -1291,10 +1279,21 @@ static int octeon3_eth_rx_one(struct oct
 				 * as it's impossible to free the skb without
 				 * freeing the work.
 				 */
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD) 
+				/*
+				 * But since this was the result to be supported 
+				 * when dis_wq_dat is not clear i.e when first data 
+				 * is not present in the left over space of work.
+				 * For now since dis_wq_dat is clear, 
+				 * freeing skb == freeing work. Hence falling 
+				 * through without complaining.
+				 */
+#else
 				WARN_ONCE(true,
 					  "unsupported intercept result %d",
 					  cb_result);
 				break;
+#endif
 			case CVM_OCT_TAKE_OWNERSHIP_SKB:
 				/* Interceptor took our packet */
 				break;
@@ -1452,38 +1451,12 @@ static void ethtool_get_drvinfo(struct n
 	strcpy(info->bus_info, "Builtin");
 }
 
-static int ethtool_get_ts_info(struct net_device *ndev,
-				      struct ethtool_ts_info *info)
-{
-	struct octeon3_ethernet *priv = netdev_priv(ndev);
-
-	if (!octeon_has_feature(OCTEON_FEATURE_PTP))
-		return 0;
-
-	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
-		SOF_TIMESTAMPING_RX_HARDWARE |
-		SOF_TIMESTAMPING_RAW_HARDWARE;
-
-	if (priv->ptp_clock)
-		info->phc_index = ptp_clock_index(priv->ptp_clock);
-	else
-		info->phc_index = -1;
-
-	info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);
-
-	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
-		(1 << HWTSTAMP_FILTER_ALL);
-
-	return 0;
-}
-
 static const struct ethtool_ops octeon3_ethtool_ops = {
 	.get_drvinfo = ethtool_get_drvinfo,
 	.get_settings = bgx_port_ethtool_get_settings,
 	.set_settings = bgx_port_ethtool_set_settings,
 	.nway_reset = bgx_port_ethtool_nway_reset,
 	.get_link = ethtool_op_get_link,
-	.get_ts_info = ethtool_get_ts_info,
 };
 
 static int octeon3_eth_ndo_change_mtu(struct net_device *netdev, int new_mtu)
@@ -1542,7 +1515,7 @@ static int octeon3_eth_common_ndo_init(s
 	union cvmx_pki_aurax_cfg pki_aura_cfg;
 	union cvmx_pki_qpg_tblx qpg_tbl;
 	int ipd_port, node_dq;
-	int base_rx_grp[MAX_RX_CONTEXTS];
+	int base_rx_grp;
 	int first_skip, later_skip;
 	struct cvmx_xport xdq;
 	int r, i;
@@ -1597,14 +1570,14 @@ static int octeon3_eth_common_ndo_init(s
 	aura2bufs_needed[priv->numa_node][priv->pki_laura] =
 		&priv->buffers_needed;
 
-	*base_rx_grp = -1;
-	r = cvmx_sso_reserve_group_range(priv->numa_node, base_rx_grp, rx_contexts);
+	base_rx_grp = -1;
+	r = cvmx_sso_reserve_group_range(priv->numa_node, &base_rx_grp, rx_contexts);
 	if (r) {
 		dev_err(netdev->dev.parent, "Failed to allocated SSO group\n");
 		return -ENODEV;
 	}
 	for (i = 0; i < rx_contexts; i++) {
-		priv->rx_cxt[i].rx_grp = base_rx_grp[i];
+		priv->rx_cxt[i].rx_grp = base_rx_grp + i;
 		priv->rx_cxt[i].parent = priv;
 
 		if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X)) {
@@ -1617,7 +1590,7 @@ static int octeon3_eth_common_ndo_init(s
 	priv->tx_complete_grp = oen->tx_complete_grp;
 	priv->pki_pkind = cvmx_helper_get_pknd(priv->xiface, priv->port_index);
 	dev_info(netdev->dev.parent, "rx sso grp:%d..%d aura:%d pknd:%d pko_queue:%d\n",
-		*base_rx_grp, *(base_rx_grp + priv->num_rx_cxt - 1), priv->pki_laura, priv->pki_pkind, priv->pko_queue);
+		base_rx_grp, base_rx_grp + priv->num_rx_cxt, priv->pki_laura, priv->pki_pkind, priv->pko_queue);
 
 	prt_schd = kzalloc(sizeof(*prt_schd), GFP_KERNEL);
 	if (!prt_schd) {
@@ -1630,7 +1603,7 @@ static int octeon3_eth_common_ndo_init(s
 	prt_schd->aura_per_prt = true;
 	prt_schd->aura_num = priv->pki_laura;
 	prt_schd->sso_grp_per_prt = true;
-	prt_schd->sso_grp = octeon3_eth_lgrp_to_ggrp(priv->numa_node, *base_rx_grp);
+	prt_schd->sso_grp = octeon3_eth_lgrp_to_ggrp(priv->numa_node, base_rx_grp);
 	prt_schd->qpg_qos = CVMX_PKI_QPG_QOS_NONE;
 
 	cvmx_helper_pki_init_port(ipd_port, prt_schd);
@@ -1645,7 +1618,16 @@ static int octeon3_eth_common_ndo_init(s
 	pki_prt_cfg.style_cfg.parm_cfg.ip6_udp_opt = false;
 	pki_prt_cfg.style_cfg.parm_cfg.ip6_udp_opt = false;
 	pki_prt_cfg.style_cfg.parm_cfg.wqe_skip = 1 * 128;
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD)
+	/*
+	 * Need to reserver more bytes in the 
+	 * first buffer in order to accomodate bigger L2 Header 
+	 * when packet is being forwarded from one port to other port
+	 */
+	first_skip = 8 * 28 + extra_skip;
+#else
 	first_skip = 8 * 21 + extra_skip;
+#endif
 	later_skip = 8 * 16;
 	pki_prt_cfg.style_cfg.parm_cfg.first_skip = first_skip;
 	pki_prt_cfg.style_cfg.parm_cfg.later_skip = later_skip;
@@ -1971,6 +1953,225 @@ static inline void octeon3_prepare_skb_t
 	skb->truesize = sizeof(*skb) + skb_end_pointer(skb) - skb->head;
 }
 
+#if defined(CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD)
+/*
+ * octeon3_transmit_qos		Function to transmit data directly using work.
+ * 				This assumes that dis_wq_dat is clear for all PKI ports 
+ * 				and hence the first segment of data is present in the work.
+ */
+int octeon3_transmit_qos(
+			struct net_device *dev,
+			void *work, 
+			int do_free,
+			int qos_level)
+{
+	cvmx_wqe_78xx_t *wqe = work;
+	struct octeon3_ethernet *priv = netdev_priv(dev);
+	union cvmx_pko_send_hdr send_hdr;
+	union cvmx_pko_buf_ptr buf_ptr;
+	union cvmx_pko_send_work send_work;
+	cvmx_pko_send_free_t send_free;
+	union cvmx_pko_send_mem send_mem;
+	union cvmx_pko_lmtdma_data lmtdma_data;
+	union cvmx_pko_query_rtn query_rtn;
+	unsigned int scr_off = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
+	unsigned int ret_off = scr_off;
+	struct sk_buff *skb = NULL;
+	struct sk_buff *skb_tmp = NULL;
+	uint64_t magic = 0;
+	int gaura = 0;
+	int frag_count;
+	bool hw_free = false;
+	void **buf = NULL;
+	void *buffers_needed = NULL;
+	void **work_wkr = NULL;
+	u64 dma_addr;
+	u8 l4_hdr = 0;
+	int l4ptr = 0;
+	unsigned int checksum_alg;
+
+	skb = octeon3_eth_work_to_skb(work);
+	
+	frag_count = 0;
+	if (skb_has_frag_list(skb))
+		skb_walk_frags(skb, skb_tmp)
+			frag_count++;
+
+	/*
+	 * In future we can do multiple segment free when nat_align is not set
+	 * using multiple PKO_SEND_FREE command
+	 */
+
+	if (do_free &&
+	    skb_shinfo(skb)->nr_frags == 0 &&
+	    skb_shared(skb) == 0 &&
+	    skb_cloned(skb) == 0 &&
+	    frag_count == 0) {
+	
+		buf = (void **)PTR_ALIGN(skb->head, 128);
+		magic = (uint64_t)buf[SKB_AURA_OFFSET];
+		if (likely(buf[SKB_PTR_OFFSET] == skb) &&
+				likely((magic & 0xfffffffffffff000) == SKB_AURA_MAGIC)) {
+			int		node;
+			int		aura;
+			
+			gaura = magic & 0xfff;
+			node = gaura >> 10;
+			aura = gaura & 0x3ff;
+			buffers_needed = aura2bufs_needed[node][aura];
+	
+			hw_free= true;
+			//printk("Debug: Aura %d\n", gaura);
+		}
+	}
+	//printk("Debug: work 0x%lx, skb 0x%lx", work, skb);
+
+	/* Adjust the port statistics. */
+	atomic64_inc(&priv->tx_packets);
+	atomic64_add(skb->len, &priv->tx_octets);
+	
+	/* Make sure packet data writes are committed before
+	 * submitting the command below
+	 */
+	wmb();
+	
+	/* Build the pko command */
+	send_hdr.u64 = 0;
+#ifdef __LITTLE_ENDIAN
+	send_hdr.s.le = 1;
+#endif
+	if (!OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+		send_hdr.s.n2 = 1; /* Don't allocate to L2 */
+
+	send_hdr.s.total = skb->len;
+	send_hdr.s.df = 1; /* Don't automatically free to FPA */
+	/* Set gaura to desired value if we need to do a free */
+	send_hdr.s.aura = gaura;
+
+	if (cvmx_wqe_is_l3_ipv4(work) || 
+	    cvmx_wqe_is_l3_ipv6(work)) {
+
+		send_hdr.s.l3ptr = ETH_HLEN + cvmx_wqe_get_unused8(work);
+	
+		if (cvmx_wqe_is_l3_ipv4(work)) {
+			send_hdr.s.ckl3 = 1;
+			l4_hdr = ip_hdr(skb)->protocol;
+			/*
+			 * Workaround for ipv4 checksum calculation
+			 */
+			send_hdr.s.l4ptr = send_hdr.s.l3ptr + (4 * ip_hdr(skb)->ihl);
+			l4ptr = send_hdr.s.l4ptr;
+
+		} else if (cvmx_wqe_is_l3_ipv6(work)) {
+
+			l4_hdr = ipv6_hdr(skb)->nexthdr;
+			l4ptr = send_hdr.s.l3ptr + sizeof(struct ipv6hdr);
+		}
+		
+		checksum_alg = 1; /* UDP == 1 */
+		switch (l4_hdr) {
+		case IPPROTO_SCTP:
+			if (OCTEON_IS_MODEL(OCTEON_CN78XX_PASS1_X))
+				break;
+			checksum_alg++; /* SCTP == 3 */
+			/* Fall through */
+		case IPPROTO_TCP: /* TCP == 2 */
+			checksum_alg++;
+			/* Fall through */
+		case IPPROTO_UDP:
+			send_hdr.s.l4ptr = l4ptr;
+			send_hdr.s.ckl4 = checksum_alg;
+			break;
+		default:
+			break;
+		}
+	}
+
+	preempt_disable();
+	cvmx_scratch_write64(scr_off, send_hdr.u64);
+	scr_off += sizeof(send_hdr);
+
+	buf_ptr.u64 = 0;
+	buf_ptr.s.subdc3 = CVMX_PKO_SENDSUBDC_LINK;
+
+	/* Pointer to first segment of data */
+	buf_ptr.s.addr = wqe->packet_ptr.addr;
+	buf_ptr.s.size = wqe->packet_ptr.size;
+
+	cvmx_scratch_write64(scr_off, buf_ptr.u64);
+	scr_off += sizeof(buf_ptr);
+
+	if (do_free && hw_free) {
+		/* Subtract 1 from buffers_needed. */
+		send_mem.u64 = 0;
+		send_mem.s.subdc4 = CVMX_PKO_SENDSUBDC_MEM;
+		send_mem.s.dsz = MEMDSZ_B64;
+		send_mem.s.alg = MEMALG_SUB;
+		send_mem.s.offset = 1;
+		send_mem.s.addr = virt_to_phys(buffers_needed);
+		cvmx_scratch_write64(scr_off, send_mem.u64);
+		scr_off += sizeof(send_mem);
+
+		/* Free buffer when finished with the packet */
+		
+		send_free.u64 = 0;
+		send_free.s.subdc4 = CVMX_PKO_SENDSUBDC_FREE;
+		buf[SKB_PTR_OFFSET] = skb;
+		send_free.s.addr = virt_to_phys(buf);
+
+
+		cvmx_scratch_write64(scr_off, send_free.u64);
+		scr_off += sizeof(send_free);
+
+		/* Reset skb before it's freed back to the fpa */
+		octeon3_prepare_skb_to_recycle(skb);
+
+	} else if (do_free) {
+		work_wkr = (void **)skb->cb;
+		work_wkr[0] = dev;
+		work_wkr[1] = NULL;
+		/* Send work when finished with the packet. */
+		send_work.u64=0;
+		send_work.s.subdc4 = CVMX_PKO_SENDSUBDC_WORK;
+		send_work.s.addr = virt_to_phys(work_wkr);
+		send_work.s.tt = CVMX_POW_TAG_TYPE_NULL;
+		send_work.s.grp = octeon3_eth_lgrp_to_ggrp(priv->numa_node, priv->tx_complete_grp);
+		cvmx_scratch_write64(scr_off, send_work.u64);
+		scr_off += sizeof(send_work);
+	}
+
+	wmb();	
+
+	lmtdma_data.u64 = 0;
+	lmtdma_data.s.scraddr = ret_off >> 3;
+	lmtdma_data.s.rtnlen = wait_pko_response ? 1 : 0;
+	lmtdma_data.s.did = 0x51;
+	lmtdma_data.s.node = priv->numa_node;
+	lmtdma_data.s.dq = priv->pko_queue;
+	dma_addr = 0xffffffffffffa400ull | ((scr_off & 0x78) - 8);
+	cvmx_write64_uint64(dma_addr, lmtdma_data.u64);
+	preempt_enable();
+
+
+	if (wait_pko_response) {
+		CVMX_SYNCIOBDMA;
+
+		query_rtn.u64 = cvmx_scratch_read64(ret_off);
+		if (unlikely(query_rtn.s.dqstatus != PKO_DQSTATUS_PASS)) {
+			netdev_err(dev, "PKO enqueue failed for fast path%llx\n",
+				   (unsigned long long)query_rtn.u64);
+
+			if (do_free) {
+				dev_kfree_skb_any(skb);
+			}
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(octeon3_transmit_qos);
+#endif
+
 static int octeon3_eth_ndo_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
 	struct sk_buff *skb_tmp;
@@ -1978,7 +2179,6 @@ static int octeon3_eth_ndo_start_xmit(st
 	unsigned int scr_off = CVMX_PKO_LMTLINE * CVMX_CACHE_LINE_SIZE;
 	unsigned int ret_off = scr_off;
 	union cvmx_pko_send_hdr send_hdr;
-	union cvmx_pko_send_ext send_ext;
 	union cvmx_pko_buf_ptr buf_ptr;
 	union cvmx_pko_send_work send_work;
 	union cvmx_pko_send_mem send_mem;
@@ -1997,7 +2197,7 @@ static int octeon3_eth_ndo_start_xmit(st
 	bool can_recycle_skb = false;
 	int gaura = 0;
 	void *buffers_needed = NULL;
-	void **buf = NULL;
+	void **buf;
 	unsigned int mss;
 
 	frag_count = 0;
@@ -2086,8 +2286,7 @@ static int octeon3_eth_ndo_start_xmit(st
 	send_hdr.s.total = skb->len;
 	send_hdr.s.aura = gaura;
 
-	if (skb->ip_summed != CHECKSUM_NONE &&
-	    skb->ip_summed != CHECKSUM_UNNECESSARY) {
+	if (skb->ip_summed != CHECKSUM_NONE) {
 #ifndef BROKEN_SIMULATOR_CSUM
 		switch (skb->protocol) {
 		case __constant_htons(ETH_P_IP):
@@ -2130,19 +2329,6 @@ static int octeon3_eth_ndo_start_xmit(st
 	cvmx_scratch_write64(scr_off, send_hdr.u64);
 	scr_off += sizeof(send_hdr);
 
-	/* Request packet to be ptp timestamped */
-	if ((unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) &&
-	    unlikely(priv->tx_timestamp_hw) && likely(!can_recycle_skb)) {
-		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
-		send_ext.u64 = 0;
-		send_ext.s.subdc4 = CVMX_PKO_SENDSUBDC_EXT;
-		send_ext.s.ra = 1;
-		send_ext.s.tstmp = 1;
-		send_ext.s.markptr = ETH_HLEN;
-		cvmx_scratch_write64(scr_off, send_ext.u64);
-		scr_off += sizeof(send_ext);
-	}
-
 	/* Add the tso descriptor if needed */
 	mss = skb_shinfo(skb)->gso_size;
 	if (mss) {
@@ -2190,19 +2376,6 @@ static int octeon3_eth_ndo_start_xmit(st
 	cvmx_scratch_write64(scr_off, send_mem.u64);
 	scr_off += sizeof(buf_ptr);
 
-	/* Write the ptp timestamp in the skb itself */
-	if ((unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) &&
-	    unlikely(priv->tx_timestamp_hw) && likely(!can_recycle_skb)) {
-		send_mem.u64 = 0;
-		send_mem.s.wmem = 1;
-		send_mem.s.subdc4 = CVMX_PKO_SENDSUBDC_MEM;
-		send_mem.s.dsz = MEMDSZ_B64;
-		send_mem.s.alg = MEMALG_SETTSTMP;
-		send_mem.s.addr = virt_to_phys(&work[1]);
-		cvmx_scratch_write64(scr_off, send_mem.u64);
-		scr_off += sizeof(send_mem);
-	}
-
 	if (likely(can_recycle_skb)) {
 		cvmx_pko_send_free_t	send_free;
 
@@ -2328,154 +2501,6 @@ static int octeon3_eth_set_mac_address(s
 	return 0;
 }
 
-static int octeon3_bgx_hwtstamp(struct net_device *netdev, int en)
-{
-	struct octeon3_ethernet		*priv = netdev_priv(netdev);
-	cvmx_xiface_t			xiface;
-	cvmx_bgxx_gmp_gmi_rxx_frm_ctl_t	frmctl;
-	cvmx_bgxx_smux_rx_frm_ctl_t	xfrmctl;
-
-	xiface = cvmx_helper_xiface_to_node_interface(priv->xiface);
-	switch (cvmx_helper_interface_get_mode(priv->xiface)) {
-	case CVMX_HELPER_INTERFACE_MODE_GMII:
-	case CVMX_HELPER_INTERFACE_MODE_RGMII:
-	case CVMX_HELPER_INTERFACE_MODE_SGMII:
-		frmctl.u64 = cvmx_read_csr_node(priv->numa_node,
-			CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(priv->port_index,
-			xiface.interface));
-		frmctl.s.ptp_mode = en;
-		cvmx_write_csr_node(priv->numa_node,
-			CVMX_BGXX_GMP_GMI_RXX_FRM_CTL(priv->port_index,
-			xiface.interface), frmctl.u64);
-		break;
-
-	case CVMX_HELPER_INTERFACE_MODE_XAUI:
-	case CVMX_HELPER_INTERFACE_MODE_RXAUI:
-	case CVMX_HELPER_INTERFACE_MODE_10G_KR:
-	case CVMX_HELPER_INTERFACE_MODE_XLAUI:
-	case CVMX_HELPER_INTERFACE_MODE_40G_KR4:
-	case CVMX_HELPER_INTERFACE_MODE_XFI:
-		xfrmctl.u64 = cvmx_read_csr_node(priv->numa_node,
-			CVMX_BGXX_SMUX_RX_FRM_CTL(priv->port_index,
-			xiface.interface));
-		xfrmctl.s.ptp_mode = en;
-		cvmx_write_csr_node(priv->numa_node,
-			CVMX_BGXX_SMUX_RX_FRM_CTL(priv->port_index,
-			xiface.interface), xfrmctl.u64);
-		break;
-
-	default:
-		/* No timestamp support*/
-		return -EOPNOTSUPP;
-	}
-
-	return 0;
-}
-
-static int octeon3_pki_hwtstamp(struct net_device *netdev, int en)
-{
-	struct octeon3_ethernet		*priv = netdev_priv(netdev);
-	struct cvmx_pki_port_config	pki_prt_cfg;
-	int				val = en ? 8 : 0;
-	int				ipd_port;
-
-	ipd_port = cvmx_helper_get_ipd_port(priv->xiface, priv->port_index);
-
-	cvmx_pki_get_port_config(ipd_port, &pki_prt_cfg);
-	pki_prt_cfg.pkind_cfg.fcs_skip = val;
-	pki_prt_cfg.pkind_cfg.inst_skip = val;
-	pki_prt_cfg.pkind_cfg.l2_scan_offset = val;
-	cvmx_pki_set_port_config(ipd_port, &pki_prt_cfg);
-
-	return 0;
-}
-
-static int octeon3_ioctl_hwtstamp(struct net_device *netdev,
-				  struct ifreq *rq, int cmd)
-{
-	struct octeon3_ethernet		*priv = netdev_priv(netdev);
-	union cvmx_mio_ptp_clock_cfg	ptp;
-	struct hwtstamp_config		config;
-	int				en;
-
-	if (!octeon_has_feature(OCTEON_FEATURE_PTP)) {
-		netdev_err(netdev, "Error: PTP clock not supported\n");
-		return -EOPNOTSUPP;
-	}
-
-	/* The PTP block should be enabled */
-	ptp.u64 = octeon_read_ptp_csr(CVMX_MIO_PTP_CLOCK_CFG);
-	if (!ptp.s.ptp_en) {
-		netdev_err(netdev, "Error: PTP clock not enabled\n");
-		return -EOPNOTSUPP;
-	}
-
-	if (copy_from_user(&config, rq->ifr_data, sizeof(config)))
-		return -EFAULT;
-
-	if (config.flags) /* reserved for future extensions */
-		return -EINVAL;
-
-	switch (config.tx_type) {
-	case HWTSTAMP_TX_OFF:
-		priv->tx_timestamp_hw = 0;
-		break;
-	case HWTSTAMP_TX_ON:
-		priv->tx_timestamp_hw = 1;
-		break;
-	default:
-		return -ERANGE;
-	}
-
-	switch (config.rx_filter) {
-	case HWTSTAMP_FILTER_NONE:
-		priv->rx_timestamp_hw = 0;
-		en = 0;
-		break;
-	case HWTSTAMP_FILTER_ALL:
-	case HWTSTAMP_FILTER_SOME:
-	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
-	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
-	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
-	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
-	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
-	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
-	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
-	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
-	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
-	case HWTSTAMP_FILTER_PTP_V2_EVENT:
-	case HWTSTAMP_FILTER_PTP_V2_SYNC:
-	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
-		priv->rx_timestamp_hw = 1;
-		en = 1;
-		break;
-	default:
-		return -ERANGE;
-	}
-
-	octeon3_bgx_hwtstamp(netdev, en);
-	octeon3_pki_hwtstamp(netdev, en);
-
-	return 0;
-}
-
-static int octeon3_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
-{
-	int rc;
-
-	switch (cmd) {
-	case SIOCSHWTSTAMP:
-		rc = octeon3_ioctl_hwtstamp(netdev, ifr, cmd);
-		break;
-
-	default:
-		rc = bgx_port_do_ioctl(netdev, ifr, cmd);
-		break;
-	}
-
-	return rc;
-}
-
 static const struct net_device_ops octeon3_eth_netdev_ops = {
 	.ndo_init		= octeon3_eth_bgx_ndo_init,
 	.ndo_uninit		= octeon3_eth_ndo_uninit,
@@ -2486,7 +2511,7 @@ static const struct net_device_ops octeo
 	.ndo_set_rx_mode	= bgx_port_set_rx_filtering,
 	.ndo_set_mac_address	= octeon3_eth_set_mac_address,
 	.ndo_change_mtu		= octeon3_eth_ndo_change_mtu,
-	.ndo_do_ioctl		= octeon3_ioctl,
+	.ndo_do_ioctl		= bgx_port_do_ioctl,
 };
 
 #if IS_ENABLED(CONFIG_OCTEON3_ETHERNET_SRIO)
@@ -2751,9 +2776,6 @@ static int octeon3_eth_probe(struct plat
 	priv->port_index = pd->port;
 	spin_lock_init(&priv->stat_lock);
 
-	if (pd->src_type == XCV)
-		snprintf(netdev->name, IFNAMSIZ, "rgmii%d", pd->port);
-
 	if (priv->mac_type == BGX_MAC)
 		netdev->netdev_ops = &octeon3_eth_netdev_ops;
 #if IS_ENABLED(CONFIG_OCTEON3_ETHERNET_SRIO)
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-nexus.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-nexus.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-nexus.c	2017-02-14 11:55:06.613532931 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-nexus.c	2017-02-14 12:07:18.131835657 +0800
@@ -125,19 +125,6 @@ static bool is_lmac_to_pki(int node, int
 	return pki_ports[node][bgx][lmac];
 }
 
-/* is_lmac_to_xcv:		Check if this lmac is connected to the xcv
- *				block (rgmii).
- *
- *  of_node:			Device node to check.
- *
- *  returns:			true if the lmac is connected to the xcv, false
- *				otherwise.
- */
-static bool is_lmac_to_xcv(struct device_node *of_node)
-{
-	return of_device_is_compatible(of_node, "cavium,octeon-7360-xcv");
-}
-
 static int bgx_probe(struct platform_device *pdev)
 {
 	struct mac_platform_data platform_data;
@@ -175,13 +162,11 @@ static int bgx_probe(struct platform_dev
 	for_each_available_child_of_node(pdev->dev.of_node, child) {
 		bool is_mix = false;
 		bool is_pki = false;
-		bool is_xcv = false;
 		union cvmx_bgxx_cmrx_config cmr_config;
 		cvmx_bgxx_cmr_global_config_t global_config;
 		struct pdev_list_item *pdev_item;
 
-		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port") &&
-		    !of_device_is_compatible(child, "cavium,octeon-7360-xcv"))
+		if (!of_device_is_compatible(child, "cavium,octeon-7890-bgx-port"))
 			continue;
 		r = of_property_read_u32(child, "reg", &port);
 		if (r)
@@ -189,7 +174,6 @@ static int bgx_probe(struct platform_dev
 
 		is_mix = is_lmac_to_mix(numa_node, interface, port);
 		is_pki = is_lmac_to_pki(numa_node, interface, port);
-		is_xcv = is_lmac_to_xcv(child);
 
 		/* Check if this port should be configured */
 		if (is_mix == false && is_pki == false)
@@ -225,10 +209,6 @@ static int bgx_probe(struct platform_dev
 		platform_data.numa_node = numa_node;
 		platform_data.interface = interface;
 		platform_data.port = port;
-		if (is_xcv)
-			platform_data.src_type = XCV;
-		else
-			platform_data.src_type = QLM;
 
 		/* Add device to the list of created devices so we can remove it
 		 * on exit.
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-port.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-port.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-port.c	2017-02-14 11:55:06.615532933 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-bgx-port.c	2017-02-14 12:07:27.617557092 +0800
@@ -305,7 +305,7 @@ int bgx_port_enable(struct net_device *n
 	cvmx_helper_set_mac_phy_mode(priv->xiface, priv->index, false);
 
 	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
-	if (cfg.s.lmac_type == 0 || cfg.s.lmac_type == 5) {
+	if (cfg.s.lmac_type == 0) {
 		/* 1G */
 		union cvmx_bgxx_gmp_gmi_txx_append tx_append;
 		union cvmx_bgxx_gmp_gmi_txx_min_pkt min_pkt;
@@ -442,7 +442,7 @@ int bgx_port_change_mtu(struct net_devic
 	max_frame = round_up(new_mtu + ETH_HLEN + ETH_FCS_LEN, 8);
 
 	cfg.u64 = cvmx_read_csr_node(priv->numa_node, CVMX_BGXX_CMRX_CONFIG(priv->index, priv->bgx_interface));
-	if (cfg.s.lmac_type == 0 || cfg.s.lmac_type == 5)
+	if (cfg.s.lmac_type == 0)
 		cvmx_write_csr_node(priv->numa_node,		/* 1G */
 				    CVMX_BGXX_GMP_GMI_RXX_JABBER(priv->index, priv->bgx_interface),
 				    max_frame);
@@ -572,9 +572,6 @@ static struct of_device_id bgx_port_matc
 	{
 		.compatible = "cavium,octeon-7890-bgx-port",
 	},
-	{
-		.compatible = "cavium,octeon-7360-xcv",
-	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, bgx_port_match);
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-common-nexus.h OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-common-nexus.h
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-common-nexus.h	2017-02-14 11:55:06.616532933 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-common-nexus.h	2017-02-14 12:07:36.864915145 +0800
@@ -32,17 +32,11 @@ enum octeon3_mac_type {
 	SRIO_MAC
 };
 
-enum octeon3_src_type {
-	QLM,
-	XCV
-};
-
 struct mac_platform_data {
 	enum octeon3_mac_type	mac_type;
 	int			numa_node;
 	int			interface;
 	int			port;
-	enum octeon3_src_type	src_type;
 };
 
 extern int octeon3_init_port_cfg_data(int node);
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-pow-ethernet.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-pow-ethernet.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-pow-ethernet.c	2017-02-14 11:55:06.616532933 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/ethernet/octeon/octeon-pow-ethernet.c	2017-02-14 12:07:42.992576901 +0800
@@ -190,22 +190,18 @@ octeon_get_next_packet_ptr(union octeon_
 
 static int octeon_pow_free_work(cvmx_wqe_t *work)
 {
-	union octeon_packet_ptr	packet_ptr;
+	union octeon_packet_ptr	segment_ptr;
+	union octeon_packet_ptr	next_ptr;
 	int			segments;
-	void			*buffer_ptr;
 
 	segments = cvmx_wqe_get_bufs(work);
 
-	packet_ptr = octeon_get_first_packet_ptr(work);
-	if (octeon_has_feature(OCTEON_FEATURE_PKI))
-		buffer_ptr = (void *)((ulong)work - 128);
-	else
-		buffer_ptr = get_buffer_ptr(packet_ptr);
-
+	segment_ptr = octeon_get_first_packet_ptr(work);
 	while (segments--) {
-		packet_ptr = octeon_get_next_packet_ptr(packet_ptr);
-		cvmx_fpa_free(buffer_ptr, cvmx_wqe_get_aura(work), 0);
-		buffer_ptr = get_buffer_ptr(packet_ptr);
+		next_ptr = octeon_get_next_packet_ptr(segment_ptr);
+		cvmx_fpa_free(get_buffer_ptr(segment_ptr),
+			      cvmx_wqe_get_aura(work), 0);
+		segment_ptr = next_ptr;
 	}
 
 	if (!octeon_has_feature(OCTEON_FEATURE_PKI))
@@ -559,10 +555,27 @@ static irqreturn_t octeon_pow_interrupt(
 	uint64_t old_group_mask = 0;
 	cvmx_wqe_t *work;
 	struct sk_buff *skb;
-	unsigned long flags = 0;
 
 	priv = netdev_priv(dev);
 
+	/* Make sure any userspace operations are complete */
+	asm volatile ("synciobdma" : : : "memory");
+
+	if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
+		/* Can get-work from group explicitly here */
+	} else if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		/* Only allow work for our group */
+		old_group_mask = cvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));
+		cvmx_write_csr(CVMX_SSO_PPX_GRP_MSK(coreid),
+			       1ull << priv->rx_group);
+		/* Read it back so it takes effect before we request work */
+		cvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));
+	} else {
+		/* Only allow work for our group */
+		old_group_mask = cvmx_read_csr(CVMX_POW_PP_GRP_MSKX(coreid));
+		cvmx_write_csr(CVMX_POW_PP_GRP_MSKX(coreid), 1 << priv->rx_group);
+	}
+
 	/* Clear the interrupt */
 	if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
 		cvmx_write_csr_node(priv->numa_node,
@@ -573,56 +586,11 @@ static irqreturn_t octeon_pow_interrupt(
 		cvmx_write_csr(CVMX_POW_WQ_INT, 1ull << priv->rx_group);
 
 	while (1) {
-		/* Non sso3 architectures need to save/restore the sso core
-		 * group mask atomically. If not, it is possible the wrong sso
-		 * core group mask is restored preventing the core from
-		 * receiving work from other groups any longer.
-		 */
-		if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE)) {
-			local_irq_save(flags);
-
-			/* Make sure any iobdma operations in progress
-			 * complete.
-			 */
-			asm volatile ("synciobdma" : : : "memory");
-		}
-
-		/* Save the sso core group mask and set it for our group */
-		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
-			old_group_mask =
-				cvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));
-			cvmx_write_csr(CVMX_SSO_PPX_GRP_MSK(coreid),
-				       1ull << priv->rx_group);
-			/* Read it back so it takes effect */
-			cvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));
-		} else if (!octeon_has_feature(OCTEON_FEATURE_PKI)) {
-			old_group_mask =
-				cvmx_read_csr(CVMX_POW_PP_GRP_MSKX(coreid));
-			cvmx_write_csr(CVMX_POW_PP_GRP_MSKX(coreid),
-				       1 << priv->rx_group);
-		}
-
 		if (octeon_has_feature(OCTEON_FEATURE_PKI))
 			work = cvmx_sso_work_request_grp_sync_nocheck(priv->rx_group,
 				CVMX_POW_NO_WAIT);
 		else
 			work = cvmx_pow_work_request_sync(0);
-
-		/* Restore the original sso core group mask */
-		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
-			cvmx_write_csr(CVMX_SSO_PPX_GRP_MSK(coreid),
-				       old_group_mask);
-			/* Must read the original pow group mask back so it
-			 * takes effect before ??
-			 */
-			cvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));
-		} else if (!octeon_has_feature(OCTEON_FEATURE_PKI))
-			cvmx_write_csr(CVMX_POW_PP_GRP_MSKX(coreid),
-				       old_group_mask);
-
-		if (!octeon_has_feature(OCTEON_FEATURE_CN78XX_WQE))
-			local_irq_restore(flags);
-
 		if (work == NULL)
 			break;
 
@@ -682,6 +650,16 @@ static irqreturn_t octeon_pow_interrupt(
 		netif_rx(skb);
 	}
 
+	/* Restore the original POW group mask */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		cvmx_write_csr(CVMX_SSO_PPX_GRP_MSK(coreid), old_group_mask);
+		/* Must read the original pow group mask back so it takes
+		 * effect before ??
+		 */
+		cvmx_read_csr(CVMX_SSO_PPX_GRP_MSK(coreid));
+	} else if (!octeon_has_feature(OCTEON_FEATURE_PKI))
+		cvmx_write_csr(CVMX_POW_PP_GRP_MSKX(coreid), old_group_mask);
+
 	return IRQ_HANDLED;
 }
 
@@ -704,7 +682,7 @@ static int octeon_pow_open(struct net_de
 	if (octeon_has_feature(OCTEON_FEATURE_PKI)) {
 		int sso_intsn = (CN78XX_SSO_INTSN_EXE << 12) | priv->rx_group;
 		struct irq_domain *d = octeon_irq_get_block_domain(priv->numa_node,
-								   CN78XX_SSO_INTSN_EXE);
+								   sso_intsn);
 		priv->rx_irq = irq_create_mapping(d, sso_intsn);
 		if (!priv->rx_irq) {
 			netdev_err(dev, "ERROR: Couldn't map hwirq: %x\n",
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/drivers/net/phy/at803x.c OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/phy/at803x.c
--- OCTEON-SDK.orig/linux/kernel/linux/drivers/net/phy/at803x.c	2015-11-21 09:53:15.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/drivers/net/phy/at803x.c	2017-02-14 12:07:50.969844802 +0800
@@ -16,6 +16,9 @@
 #include <linux/string.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
+#include "liteon_config.h" //liteon add +
+#include <linux/of_device.h>  //liteon add +
+#include <linux/of_platform.h> //liteon add +
 
 #define AT803X_INTR_ENABLE			0x12
 #define AT803X_INTR_STATUS			0x13
@@ -32,6 +35,24 @@ MODULE_DESCRIPTION("Atheros 803x PHY dri
 MODULE_AUTHOR("Matus Ujhelyi");
 MODULE_LICENSE("GPL");
 
+
+//liteon+
+#include "athrs17_phy.h"
+#define PROC_ENTRY  1
+#if PROC_ENTRY
+struct phy_device *my_phydev=NULL;
+#include <linux/proc_fs.h>
+#endif
+uint32_t athrs17_reg_read(struct phy_device *phydev,uint32_t reg_addr);
+void athrs17_reg_write(struct phy_device *phydev, uint32_t reg_addr, uint32_t reg_val);
+static uint8_t athr17_init_flag = 0;
+
+ const char *sprop;
+
+
+
+//liteon-
+
 static void at803x_set_wol_mac_addr(struct phy_device *phydev)
 {
 	struct net_device *ndev = phydev->attached_dev;
@@ -108,6 +129,623 @@ static int at803x_config_init(struct phy
 	return 0;
 }
 
+//liteon+
+
+void phy_mode_setup(void)
+{
+#if 0
+#ifdef ATHRS17_VER_1_0
+
+  /*work around for phy4 rgmii mode*/
+  phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 18);
+  phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x480c);
+
+  /*rx delay*/
+  phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 0);
+  phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x824e);
+
+  /*tx delay*/
+  phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 29, 5);
+  phy_reg_write(ATHR_PHYBASE(ATHR_IND_PHY), ATHR_PHYADDR(ATHR_IND_PHY), 30, 0x3d47);
+
+#endif
+#endif
+}  
+
+/*
+ * V-lan configuration given by Switch team
+ * Vlan 1:PHY0,1,2,3 and Mac 0 of s17
+ * Vlam 2:PHY4 and Mac 6 of s17
+ */
+
+void athrs17_vlan_config(struct phy_device *phydev)
+{
+
+	if (strcmp(sprop,"cavium,wp868cp,wp868cp_v4"))//liteon add +
+	{
+		athrs17_reg_write(phydev,S17_P0LOOKUP_CTRL_REG, 0x0014001e);
+		athrs17_reg_write(phydev,S17_P0VLAN_CTRL0_REG, 0x10001);
+
+		athrs17_reg_write(phydev,S17_P1LOOKUP_CTRL_REG, 0x0014001d);
+		athrs17_reg_write(phydev,S17_P1VLAN_CTRL0_REG, 0x10001);
+
+		athrs17_reg_write(phydev,S17_P2LOOKUP_CTRL_REG, 0x0014001b);
+		athrs17_reg_write(phydev,S17_P2VLAN_CTRL0_REG, 0x10001);
+
+		athrs17_reg_write(phydev,S17_P3LOOKUP_CTRL_REG, 0x00140017);
+		athrs17_reg_write(phydev,S17_P3VLAN_CTRL0_REG, 0x10001);
+
+		athrs17_reg_write(phydev,S17_P4LOOKUP_CTRL_REG, 0x0014000f);
+		athrs17_reg_write(phydev,S17_P4VLAN_CTRL0_REG, 0x10001);
+
+		athrs17_reg_write(phydev,S17_P5LOOKUP_CTRL_REG, 0x00140040);
+		athrs17_reg_write(phydev,S17_P5VLAN_CTRL0_REG, 0x20001);
+
+		athrs17_reg_write(phydev,S17_P6LOOKUP_CTRL_REG, 0x00140020);
+		athrs17_reg_write(phydev,S17_P6VLAN_CTRL0_REG, 0x20001);
+	}
+	else
+	{
+		//liteon add +
+		
+		athrs17_reg_write(phydev,S17_P0LOOKUP_CTRL_REG, 0x00140004);
+		athrs17_reg_write(phydev,S17_P0VLAN_CTRL0_REG, 0x10001);
+
+		athrs17_reg_write(phydev,S17_P2LOOKUP_CTRL_REG, 0x00140001);
+		athrs17_reg_write(phydev,S17_P2VLAN_CTRL0_REG, 0x10001);
+
+		athrs17_reg_write(phydev,S17_P3LOOKUP_CTRL_REG, 0x00140040);
+		athrs17_reg_write(phydev,S17_P3VLAN_CTRL0_REG, 0x20001);
+
+		athrs17_reg_write(phydev,S17_P6LOOKUP_CTRL_REG, 0x00140008);
+		athrs17_reg_write(phydev,S17_P6VLAN_CTRL0_REG, 0x20001);	
+		//liteon add +
+	}
+}
+
+void athrs17_reg_init_wan(struct phy_device *phydev)
+{
+#define ATH_S17_MAC0_SGMII
+#ifdef ATH_S17_MAC0_SGMII
+    //athrs17_reg_write(phydev,S17_P6PAD_MODE_REG,0x07600000);
+	athrs17_reg_write(phydev,S17_P6PAD_MODE_REG,0x07000000);
+#else
+    athrs17_reg_write(phydev,S17_P6PAD_MODE_REG,
+    athrs17_reg_read(phydev,S17_P6PAD_MODE_REG)|S17_MAC6_SGMII_EN);
+#endif
+    athrs17_reg_write(phydev,S17_P6STATUS_REG, S17_PORT_STATUS_AZ_DEFAULT);
+//liteon+
+    athrs17_reg_write(phydev,S17_SGMII_CTRL_REG , 0xc78164de); /* SGMII control */
+//liteon-
+
+    athrs17_vlan_config(phydev);
+    printk(KERN_ERR"%s done\n",__func__);
+
+}
+
+
+static int qca8334_config_init(struct phy_device *phydev)
+{
+	int val;
+	u32 features;
+	int status;
+
+    if (athr17_init_flag)
+    {
+        printk(KERN_ERR"athr17_init_flag=1\n");
+      return -1;
+    }
+
+    athrs17_reg_write(phydev,S17_P0PAD_MODE_REG, S17_MAC0_SGMII_EN);
+
+    athrs17_reg_write(phydev,S17_P0STATUS_REG,  0x0000007e);
+    //athrs17_reg_write(phydev,S17_P0STATUS_REG,  0x00001280);
+	//athrs17_reg_write(phydev,S17_P0PAD_MODE_REG,   0x00080080);
+	
+	//liteon add +
+	if (strcmp(sprop,"cavium,wp868cp,wp868cp_v4"))
+		athrs17_reg_write(phydev,S17_P0PAD_MODE_REG,   0x00080080);
+	else
+		athrs17_reg_write(phydev,S17_P0PAD_MODE_REG,   0x80080080);
+	//liteon add +
+	
+    athrs17_reg_write(phydev,S17_GLOFW_CTRL1_REG,  0x007f7f7f);
+
+    //phy mode
+    athrs17_reg_write(phydev,S17_SGMII_CTRL_REG , 0xc74164de); /* SGMII control */
+    
+    //mac mode
+    //athrs17_reg_write(phydev,S17_SGMII_CTRL_REG , 0xc78164de); /* SGMII control */
+
+
+    
+	features = SUPPORTED_TP | SUPPORTED_MII | SUPPORTED_AUI |
+		   SUPPORTED_FIBRE | SUPPORTED_BNC;
+     
+
+	val = phy_read(phydev, MII_BMSR);
+	if (val < 0)
+		return val;
+
+	if (val & BMSR_ANEGCAPABLE)
+		features |= SUPPORTED_Autoneg;
+	if (val & BMSR_100FULL)
+		features |= SUPPORTED_100baseT_Full;
+	if (val & BMSR_100HALF)
+		features |= SUPPORTED_100baseT_Half;
+	if (val & BMSR_10FULL)
+		features |= SUPPORTED_10baseT_Full;
+	if (val & BMSR_10HALF)
+		features |= SUPPORTED_10baseT_Half;
+
+	if (val & BMSR_ESTATEN) {
+		val = phy_read(phydev, MII_ESTATUS);
+		if (val < 0)
+			return val;
+
+		if (val & ESTATUS_1000_TFULL)
+			features |= SUPPORTED_1000baseT_Full;
+		if (val & ESTATUS_1000_THALF)
+			features |= SUPPORTED_1000baseT_Half;
+	}
+
+	phydev->supported = features;
+	phydev->advertising = features;
+
+
+#ifdef PHY_LED    
+    printf("\n LED0=0x%x\n",athrs17_reg_read(phydev,S17_LED_CTRL0_REG));
+    printf("\n LED1=0x%x\n",athrs17_reg_read(phydev,S17_LED_CTRL1_REG));
+    printf("\n LED2=0x%x\n",athrs17_reg_read(phydev,S17_LED_CTRL2_REG));
+    printf("\n LED3=0x%x\n",athrs17_reg_read(phydev,S17_LED_CTRL3_REG));
+    athrs17_reg_write(phydev,S17_LED_CTRL0_REG , 0x00008000);
+    athrs17_reg_write(phydev,S17_LED_CTRL1_REG , 0x00008000);
+    athrs17_reg_write(phydev,S17_LED_CTRL2_REG , 0x00008000);
+    athrs17_reg_write(phydev,S17_LED_CTRL3_REG , 0x03faaa00);
+#endif        
+
+    //athr17_init_flag = 1;
+	//athrs17_reg_init_wan(phydev);
+	
+	//liteon add +
+	if (!strcmp(sprop,"cavium,wp868cp,wp868cp_v4"))
+		athrs17_reg_init_wan(phydev);
+	//liteon add +
+		
+		
+    //phy reset
+	status = phy_write(phydev,ATHR_PHY_CONTROL , ATHR_CTRL_SOFTWARE_RESET);
+    //printk(KERN_ERR"__status=%d\n",status);
+
+
+    //genphy_config_aneg(phydev);
+
+    //liteon+
+    //set this  flag for switch chip,
+    //because cavium does not support switch chip.
+    phydev->irq = PHY_POLL;
+    //liteon-
+
+    printk(KERN_ERR"%s: complete\n",__func__);
+	return 0;
+}
+
+uint32_t athrs17_reg_read(struct phy_device *phydev,uint32_t reg_addr)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr, tmp_val, reg_val;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+
+    //liteon+
+    int org_phy_addr = phydev->addr;
+    //liteon-
+
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+    //printk(KERN_ERR"__286_org_phy_addr=%d\n",phydev->addr);
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    //liteon+
+    phydev->addr = phy_addr;
+    ////liteon-
+    phy_write(phydev, phy_reg, phy_val);
+    
+    /* For some registers such as MIBs, since it is read/clear, we should */
+    /* read the lower 16-bit register then the higher one */
+    
+    /* read register in lower address */
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    //liteon+
+    phydev->addr = phy_addr;
+    //liteon-
+    reg_val = (uint32_t) phy_read(phydev, phy_reg);
+    
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    //liteon+
+    phydev->addr = phy_addr;
+    //liteon-
+    tmp_val = (uint32_t) phy_read(phydev, phy_reg);
+    reg_val |= (tmp_val << 16);
+    
+    //liteon+
+    phydev->addr = org_phy_addr;
+    //liteon-
+    
+    return reg_val;
+    
+}
+
+void athrs17_reg_write(struct phy_device *phydev, uint32_t reg_addr, uint32_t reg_val)
+{
+    uint32_t reg_word_addr;
+    uint32_t phy_addr;
+    uint16_t phy_val;
+    uint8_t phy_reg;
+//liteon+
+    int org_phy_addr = phydev->addr;
+//liteon-
+    //printk(KERN_ERR"__327__org_phy_addr=%d\n",phydev->addr);
+    
+    /* change reg_addr to 16-bit word address, 32-bit aligned */
+    reg_word_addr = (reg_addr & 0xfffffffc) >> 1;
+
+    /* configure register high address */
+    phy_addr = 0x18;
+    phy_reg = 0x0;
+    phy_val = (uint16_t) ((reg_word_addr >> 8) & 0x1ff);  /* bit16-8 of reg address */
+    //liteon+
+    phydev->addr = phy_addr;
+    //liteon-
+    phy_write(phydev, phy_reg, phy_val);
+    
+    /* For some registers such as ARL and VLAN, since they include BUSY bit */
+    /* in lower address, we should write the higher 16-bit register then the */
+    /* lower one */
+
+    /* read register in higher address */
+    reg_word_addr++;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) ((reg_val >> 16) & 0xffff);
+    //liteon+
+    phydev->addr = phy_addr;
+    //liteon-
+    phy_write(phydev, phy_reg, phy_val);
+
+    /* write register in lower address */
+    reg_word_addr--;
+    phy_addr = 0x10 | ((reg_word_addr >> 5) & 0x7); /* bit7-5 of reg address */
+    phy_reg = (uint8_t) (reg_word_addr & 0x1f);   /* bit4-0 of reg address */
+    phy_val = (uint16_t) (reg_val & 0xffff);
+    //liteon+
+    phydev->addr = phy_addr;
+    //liteon-
+    phy_write(phydev, phy_reg, phy_val);
+
+    //liteon+
+    phydev->addr = org_phy_addr;
+    //liteon-
+}
+
+int qca8334_read_status(struct phy_device *phydev)
+{
+  int phy_status;
+  int pma_ctrl1;
+  int org_addr = phydev->addr;
+  int i=0;
+
+  //printk(KERN_ERR"__399__org_phy_addr=%d\n",phydev->addr);
+
+  phydev->link = 0;
+
+	if (strcmp(sprop,"cavium,wp868cp,wp868cp_v4"))
+	{
+	  for (i=0;i<4;i++)//liteon mark -
+	  {
+		   phydev->addr = i;
+
+		/* All the speed information can be read from register 17 in one go. */
+		phy_status = phy_read(phydev, 17);
+		//printk("2..phy_status=0x%x,phy_addr=%d,link=%d\n",phy_status,phydev->addr,phydev->link);
+	   
+		/* If the resolve bit 11 isn't set, see if autoneg is turned off
+		   (bit 12, reg 0). The resolve bit doesn't get set properly when
+		   autoneg is off, so force it */
+		if ((phy_status & (1 << 11)) == 0) 
+		{
+			int auto_status = phy_read(phydev, 0);
+			//printk(KERN_ERR"__379__\n");
+			//printk(KERN_ERR"..auto_status=0x%x\n",auto_status);
+
+			if ((auto_status & (1 << 12)) == 0)
+			{
+				//printk(KERN_ERR"\n__382__");
+				phy_status |= 1 << 11;
+			}
+		}
+
+
+	   /* Only return a link if the PHY has finished auto negotiation
+		*    and set the resolved bit (bit 11) */
+		   if (phy_status & (1 << 11)) 
+		   {
+			  phydev->link = 1;
+
+			  if ((phy_status >> 13) & 1)
+					phydev->duplex = DUPLEX_FULL ;
+
+			  switch ((phy_status >> 14) & 3) 
+			  {
+				case 0: /* 10 Mbps */
+					  phydev->speed = SPEED_10;
+					  break;
+				case 1: /* 100 Mbps */
+					  phydev->speed = SPEED_100;
+					  break;
+				case 2: /* 1 Gbps */
+					  phydev->speed = SPEED_1000;
+					  break;
+				case 3: /* Illegal */
+					  phydev->speed = 0;
+					  break;
+			  }
+		  }
+
+		   if (phydev->link)
+		   {
+			 //printk("link=%d",phydev->link);
+			   break;  
+		   }
+	  }
+	  if (phydev->duplex == DUPLEX_FULL)
+			phydev->pause = phydev->asym_pause = (phy_status >> 2) & 1;
+	  
+	  phydev->addr = org_addr;
+		return 0;
+	}
+	//liteon add +
+	else
+	{
+	  //for (i=0;i<4;i++)
+	  //{
+		   //phydev->addr = i;
+
+		/* All the speed information can be read from register 17 in one go. */
+		phy_status = phy_read(phydev, 17);
+		//printk("2..phy_status=0x%x,phy_addr=%d,link=%d\n",phy_status,phydev->addr,phydev->link);
+	   
+		/* If the resolve bit 11 isn't set, see if autoneg is turned off
+		   (bit 12, reg 0). The resolve bit doesn't get set properly when
+		   autoneg is off, so force it */
+		if ((phy_status & (1 << 11)) == 0) 
+		{
+			int auto_status = phy_read(phydev, 0);
+			//printk(KERN_ERR"__379__\n");
+			//printk(KERN_ERR"..auto_status=0x%x\n",auto_status);
+
+			if ((auto_status & (1 << 12)) == 0)
+			{
+				//printk(KERN_ERR"\n__382__");
+				phy_status |= 1 << 11;
+			}
+		}
+
+
+	   /* Only return a link if the PHY has finished auto negotiation
+		*    and set the resolved bit (bit 11) */
+		   if (phy_status & (1 << 11)) 
+		   {
+			  phydev->link = 1;
+
+			  if ((phy_status >> 13) & 1)
+					phydev->duplex = DUPLEX_FULL ;
+
+			  switch ((phy_status >> 14) & 3) 
+			  {
+				case 0: /* 10 Mbps */
+					  phydev->speed = SPEED_10;
+					  break;
+				case 1: /* 100 Mbps */
+					  phydev->speed = SPEED_100;
+					  break;
+				case 2: /* 1 Gbps */
+					  phydev->speed = SPEED_1000;
+					  break;
+				case 3: /* Illegal */
+					  phydev->speed = 0;
+					  break;
+			  }
+		  }
+
+		   if (phydev->link)
+		   {
+			 //printk("link=%d",phydev->link);
+			 //break;  
+		   }
+	  //}
+	  if (phydev->duplex == DUPLEX_FULL)
+			phydev->pause = phydev->asym_pause = (phy_status >> 2) & 1;
+	  
+	  phydev->addr = org_addr;
+		return 0;	
+	}
+//liteon add +
+}
+
+static int qca8334_config_aneg(struct phy_device *phydev)
+{
+      int err;
+      int i;
+      int org_addr = phydev->addr;
+
+      //printk(KERN_ERR"__474__qca8334_config_aneg\n");
+      
+      //save to global var
+      my_phydev = phydev;
+
+      //for (i=0;i<4;i++)
+      //{
+          //err = phy_write(phydev, MII_BMCR, BMCR_RESET);
+          //if (err < 0)
+          //   return err;
+
+      #if 0
+      err = phy_write(phydev, MII_M1011_PHY_SCR, MII_M1011_PHY_SCR_AUTO_CROSS);
+      if (err < 0)
+         return err;
+      #endif
+
+      for (i=0;i<4;i++)
+      {
+           phydev->addr = i;
+           err = genphy_config_aneg(phydev);
+           //printk(KERN_ERR"ang_val=0x%x\n",err);
+      }
+
+      phydev->addr = org_addr;
+      return err;
+}
+
+
+static int qca8334_phy_is_link_alive(struct phy_device *phydev)
+{
+  uint16_t phyHwStatus;
+  phyHwStatus = phy_read(phydev, 17);
+
+  if (phyHwStatus & S17_STATUS_LINK_PASS)
+    return 1;
+
+
+      return 0;
+}
+
+
+#if 1
+static int qca8334_ack_interrupt(struct phy_device *phydev)
+{
+	int err;
+
+	err = phy_read(phydev, ATHR_PHY_INTR_STATUS);
+
+    //printk(KERN_ERR"ack_intr=0x%x\n",err);
+
+	return (err < 0) ? err : 0;
+}
+
+
+static int qca8334_config_interrupt(struct phy_device *phydev)
+{
+	int err;
+
+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
+    {
+		err = phy_write(phydev, ATHR_PHY_INTR_CONTROL,ATHR_PHY_INTRS);
+
+        //printk(KERN_ERR"config_intr1=0x%x\n",err);
+    }
+	else
+    {
+		err = phy_write(phydev, ATHR_PHY_INTR_CONTROL, 0);
+        //printk(KERN_ERR"config_intr2=0x%x\n",err);
+        athr17_init_flag = 0;
+
+    //printk(KERN_ERR"__286_org_phy_addr=%d\n",phydev->addr);
+    }
+
+	return  err;
+}
+
+
+static int qca8334_ack_interrupt_(struct phy_device *phydev)
+{
+    int status = 0, intr_reg_val;
+    uint32_t phyUnit = 0 ,phyOrgAddr = 0;
+    uint32_t phymask = 0x0;
+    uint32_t linkDown = 0x0;
+    //athr_gmac_t *mac0 = athr_macs[0];
+
+    //store original phy_addr
+    phyOrgAddr = phydev->addr;
+
+    athrs17_reg_write(phydev, S17_GLOBAL_INTMASK1, 0x0);
+
+    intr_reg_val = athrs17_reg_read(phydev, S17_GLOBAL_INT1_REG);
+
+    /* clear global link interrupt */
+    athrs17_reg_write(phydev, S17_GLOBAL_INT1_REG, intr_reg_val);
+
+    if (intr_reg_val & S17_GLOBAL_INT_PHYMASK)
+    {
+        for (phyUnit=0; phyUnit < S17_PHY_MAX; phyUnit++)
+        {
+            phydev->addr = phyUnit;
+            status = phy_read(phydev, ATHR_PHY_INTR_STATUS);
+
+            if(status & ATHR_PHY_INTR_LINK_UP)
+            {
+                printk(KERN_ERR"LINK UP - Port %d:%x\n",phyUnit,status);
+                phymask = (phymask | (1 << phyUnit));
+            }
+            if(status & ATHR_PHY_INTR_LINK_DOWN)
+            {
+                printk(KERN_ERR"LINK DOWN - Port %d:%x\n",phyUnit,status);
+                phymask = (phymask | (1 << phyUnit));
+                linkDown = (linkDown | (1 << phyUnit));
+            }
+            if(status & ATHR_PHY_INTR_DUPLEX_CHANGE)
+            {
+                printk(KERN_ERR"LINK DUPLEX CHANGE - Port %d:%x\n",phyUnit,status);
+                phymask = (phymask | (1 << phyUnit));
+            }
+            if(status & ATHR_PHY_INTR_SPEED_CHANGE)
+            {
+                printk(KERN_ERR"LINK SPEED CHANGE %d:%x\n",phyUnit,status);
+                phymask = (phymask | (1 << phyUnit));
+            }
+        }
+        for (phyUnit=0; phyUnit < S17_PHY_MAX; phyUnit++)
+        {
+            if ((phymask >> phyUnit) & 0x1)
+            {
+               phydev->addr = phyUnit ;
+
+               status = phy_read(phydev,ATHR_PHY_INTR_STATUS);
+
+               if (!qca8334_phy_is_link_alive(phydev) && !((linkDown >> phyUnit) & 0x1))
+                   continue;
+               //mac0->ops->check_link(mac0,phyUnit);
+
+               //liteon+
+               return phymask;
+               //liteon-
+            }
+        }
+
+        athrs17_reg_write(phydev, S17_GLOBAL_INTMASK1, S17_GLOBAL_INT_PHYMASK);
+
+    }
+    else
+    {
+        printk(KERN_ERR"Spurious link interrupt:%s,status:%x\n",__func__,status);
+        athrs17_reg_write(phydev, S17_GLOBAL_INTMASK1, S17_GLOBAL_INT_PHYMASK);
+    }
+
+    //restore original phy_addr
+    phydev->addr = phyOrgAddr ;
+
+    return 0;
+}
+#endif
+//liteon-
+
 /* ATHEROS 8035 */
 static struct phy_driver at8035_driver = {
 	.phy_id		= 0x004dd072,
@@ -154,6 +792,129 @@ static struct phy_driver at8030_driver =
 	},
 };
 
+//liteon+
+/* ATHEROS QCA8334 */
+static struct phy_driver qca8334_driver = {
+	.phy_id		= 0x004dd036,
+	.name		= "Atheros 8334 ethernet",
+	.phy_id_mask	= 0xfffffff0,
+	.config_init	= qca8334_config_init,
+	.features	= PHY_GBIT_FEATURES,
+	//.flags		= PHY_HAS_INTERRUPT,
+    .flags      = PHY_HAS_MAGICANEG | PHY_HAS_INTERRUPT | PHY_QCA_SWITCH,
+    //.flags      = PHY_HAS_INTERRUPT | PHY_HAS_MAGICANEG,
+    //.flags      = PHY_POLL,
+	//.ack_interrupt	= &rtl821x_ack_interrupt,
+	//.config_intr	= &rtl8211b_config_intr,
+	.ack_interrupt	= qca8334_ack_interrupt,
+    .config_intr  = qca8334_config_interrupt,
+    .config_aneg = qca8334_config_aneg,
+	//.config_aneg	= &genphy_config_aneg,
+    .read_status = qca8334_read_status,
+	//.read_status	= &genphy_read_status,
+	.driver		= {
+		.owner = THIS_MODULE,
+	},
+};
+
+
+#if PROC_ENTRY
+uint32_t g_reg_num=0;
+unsigned int g_eth_n=0,g_reg=0;
+uint32_t g_reg_val=0;
+
+static int phy_proc_write(struct file *file, const char *buf, unsigned long count, void *data)
+{
+   char cmd_buf[256]; 
+   int ret;
+
+   unsigned int eth_n,reg,rw;
+   uint32_t reg_val;
+   
+
+   if (count == 0)return -1;
+   if(count > 255)count = 255;
+
+   ret = copy_from_user(cmd_buf, buf, count);
+   if (ret < 0)return -1;
+
+   cmd_buf[count] = '\0';
+   printk("qca8334 write reg = %s\n", cmd_buf);
+
+   sscanf(cmd_buf, "%d %d %x %x " ,&rw,&eth_n, &reg,&reg_val);
+
+   printk(" rw=%d ,eth_port=%d, reg_addr=0x%x , reg_val=0x%x \n" ,rw, eth_n, reg, reg_val);
+  
+   if (my_phydev)
+   {
+       if (rw)
+       {
+
+       g_eth_n = my_phydev->addr = eth_n;
+       g_reg = reg;
+       g_reg_val = reg_val;
+       athrs17_reg_write(my_phydev,g_reg , reg_val);
+       }
+       else
+       {
+           my_phydev->addr = eth_n;
+           printk("reg%x =0x%x\n",reg,athrs17_reg_read(my_phydev,reg ));
+       }
+   }
+
+
+
+   return count;
+}
+
+static int qca8334_proc_show(struct seq_file *seq, void *offset)
+{
+    int err;
+    //seq_printf(seq,"__proc__test=%s\n",__func__);
+
+#if 1
+    if (my_phydev)
+    {
+    seq_printf(seq,"reg:0x%x=0x%x\n",g_reg,athrs17_reg_read(my_phydev,g_reg ));
+
+    }
+#endif
+
+    return 0;
+}
+
+static int qca8334_proc_open(struct inode *inode, struct file *file)
+{
+    int ret;
+
+    if (!try_module_get(THIS_MODULE))
+       return -ENODEV;
+
+    ret = single_open(file, qca8334_proc_show, NULL);
+    if (ret)
+       module_put(THIS_MODULE);
+
+    return ret;
+}
+
+static int qca8334_proc_release(struct inode *inode, struct file *file)
+{
+    int res = single_release(inode, file);
+    module_put(THIS_MODULE);
+
+    return res;
+}
+
+static const struct file_operations qca8334_proc_fops = {
+    .open       = qca8334_proc_open,
+    .read       = seq_read,
+    .write      = phy_proc_write,
+    .llseek     = seq_lseek,
+    .release    = qca8334_proc_release,
+};
+#endif
+//liteon-
+
 static int __init atheros_init(void)
 {
 	int ret;
@@ -162,18 +923,42 @@ static int __init atheros_init(void)
 	if (ret)
 		goto err1;
 
-	ret = phy_driver_register(&at8033_driver);
-	if (ret)
-		goto err2;
+//	ret = phy_driver_register(&at8033_driver);
+//	if (ret)
+//		goto err2;
 
 	ret = phy_driver_register(&at8030_driver);
 	if (ret)
 		goto err3;
-
-	return 0;
+//liteon+
+    ret = phy_driver_register(&qca8334_driver);
+#if PROC_ENTRY
+    struct proc_file_entry *fe = proc_create("qca8334", 0667, NULL,&qca8334_proc_fops);
+    if (!fe) 
+    {
+        remove_proc_entry("qca8334", 0);
+        return -EIO;
+    }
+#endif
+    if (ret)
+        goto err4;
+//liteon-
+
+//liteon add +
+	sprop = of_get_property(of_find_node_by_path("/"),"model",NULL);
+	
+//liteon add +
+ 
+ 	return 0;
+ 
+//liteon+
+err4:
+    phy_driver_unregister(&qca8334_driver);
+    return ret;
+//liteon-    
 
 err3:
-	phy_driver_unregister(&at8033_driver);
+//	phy_driver_unregister(&at8033_driver);
 err2:
 	phy_driver_unregister(&at8035_driver);
 err1:
@@ -183,8 +968,11 @@ err1:
 static void __exit atheros_exit(void)
 {
 	phy_driver_unregister(&at8035_driver);
-	phy_driver_unregister(&at8033_driver);
+//	phy_driver_unregister(&at8033_driver);
 	phy_driver_unregister(&at8030_driver);
+//liteon+    
+	phy_driver_unregister(&qca8334_driver);
+//liteon-    
 }
 
 module_init(atheros_init);
@@ -192,8 +980,11 @@ module_exit(atheros_exit);
 
 static struct mdio_device_id __maybe_unused atheros_tbl[] = {
 	{ 0x004dd076, 0xffffffef },
-	{ 0x004dd074, 0xffffffef },
+//	{ 0x004dd074, 0xffffffef },
 	{ 0x004dd072, 0xffffffef },
+//liteon+    
+	{ 0x004dd036, 0xfffffff0 },
+//liteon-    
 	{ }
 };
 
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/include/linux/etherdevice.h OCTEON-SDKsffnand/linux/kernel/linux/include/linux/etherdevice.h
--- OCTEON-SDK.orig/linux/kernel/linux/include/linux/etherdevice.h	2015-11-21 09:52:57.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/include/linux/etherdevice.h	2017-02-14 12:08:00.207741640 +0800
@@ -249,13 +249,14 @@ static inline void ether_addr_copy(u8 *d
  * Copy the Ethernet address from one net_device to another along with
  * the address attributes (addr_assign_type).
  */
+/*
 static inline void eth_hw_addr_inherit(struct net_device *dst,
 				       struct net_device *src)
 {
 	dst->addr_assign_type = src->addr_assign_type;
 	ether_addr_copy(dst->dev_addr, src->dev_addr);
 }
-
+*/
 /**
  * compare_ether_addr - Compare two Ethernet addresses
  * @addr1: Pointer to a six-byte array containing the Ethernet address
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/include/linux/netdevice.h OCTEON-SDKsffnand/linux/kernel/linux/include/linux/netdevice.h
--- OCTEON-SDK.orig/linux/kernel/linux/include/linux/netdevice.h	2015-11-21 09:52:56.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/include/linux/netdevice.h	2017-02-14 12:08:06.607468768 +0800
@@ -2976,4 +2976,11 @@ do {								\
 #define PTYPE_HASH_SIZE	(16)
 #define PTYPE_HASH_MASK	(PTYPE_HASH_SIZE - 1)
 
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+/* Cavium fast-path rx/tx hooks */
+extern u32 (*cvm_br_rx_hook) (struct sk_buff *);
+extern u32 (*cvm_ipfwd_rx_hook)(struct sk_buff *);
+extern int (*cvm_ipfwd_tx_hook)(struct sk_buff *);
+#endif
+
 #endif	/* _LINUX_NETDEVICE_H */
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/include/linux/phy.h OCTEON-SDKsffnand/linux/kernel/linux/include/linux/phy.h
--- OCTEON-SDK.orig/linux/kernel/linux/include/linux/phy.h	2015-11-21 09:52:57.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/include/linux/phy.h	2017-02-14 12:08:13.621347521 +0800
@@ -25,6 +25,10 @@
 #include <linux/workqueue.h>
 #include <linux/mod_devicetable.h>
 
+// liteon add >>>
+#define ENABLE_VSC8574  1
+#define PHY_QCA_SWITCH    0x000000F0
+// liteon add <<<
 #include <linux/atomic.h>
 
 #define PHY_BASIC_FEATURES	(SUPPORTED_10baseT_Half | \
@@ -56,6 +60,11 @@ typedef enum {
 	PHY_INTERFACE_MODE_MII,
 	PHY_INTERFACE_MODE_GMII,
 	PHY_INTERFACE_MODE_SGMII,
+// liteon add >>>
+#ifdef ENABLE_VSC8574  
+	PHY_INTERFACE_MODE_QSGMII,
+#endif
+// liteon add <<<
 	PHY_INTERFACE_MODE_TBI,
 	PHY_INTERFACE_MODE_RMII,
 	PHY_INTERFACE_MODE_RGMII,
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/include/linux/skbuff.h OCTEON-SDKsffnand/linux/kernel/linux/include/linux/skbuff.h
--- OCTEON-SDK.orig/linux/kernel/linux/include/linux/skbuff.h	2015-11-21 09:52:57.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/include/linux/skbuff.h	2017-02-14 12:08:25.100118190 +0800
@@ -335,6 +335,129 @@ typedef unsigned int sk_buff_data_t;
 typedef unsigned char *sk_buff_data_t;
 #endif
 
+
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+
+struct iphdr_new {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8    ihl:4,
+                version:4;
+#elif defined (__BIG_ENDIAN_BITFIELD)
+        __u8    version:4,
+                ihl:4;
+#else
+#error  "Please fix <asm/byteorder.h>"
+#endif
+        __u8    tos;
+        __be16  tot_len;
+        __be16  id;
+        __be16  frag_off;
+        __u8    ttl;
+        __u8    protocol;
+        __sum16 check;
+        __be32  saddr;
+        __be32  daddr;
+        /*The options start here. */
+};
+
+struct ipv6hdr_new {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8			priority:4,
+				version:4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8			version:4,
+				priority:4;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+	__u8			flow_lbl[3];
+
+	__be16			payload_len;
+	__u8			nexthdr;
+	__u8			hop_limit;
+
+	uint64_t                saddrhi;
+	uint64_t                saddrlo;
+	uint64_t                daddrhi;
+	uint64_t                daddrlo;
+};
+
+struct cvm_udphdr {
+	__be16	source;
+	__be16	dest;
+	__be16	len;
+	__sum16	check;
+};
+
+struct cvm_pppoe_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+        __u8 ver : 4;
+        __u8 type : 4;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+        __u8 type : 4;
+        __u8 ver : 4;
+#else
+#error  "Please fix <asm/byteorder.h>"
+#endif
+        __u8 code;
+        __be16 sid;
+        __be16 length;
+};  
+
+struct cvm_vlan_hdr {
+	__be16 h_vlan_TCI;
+	__be16 h_vlan_encapsulated_proto;
+};
+
+struct cvm_vxlan_hdr {
+	__be32 vx_flags;
+	__be32 vx_vni;
+};
+
+struct gre_hdr_info {
+        __be16 flags;
+        __be16 protocol;
+	__be32 key;
+	__be32 headroom;
+};
+
+
+typedef struct {
+	unsigned long		rx_pkt_flags;
+	unsigned long		tx_pkt_flags;
+	u32			cookie;		/* magic number */
+	void			*bucket;	/* bucket ptr */
+	void			*frag_bucket;	/* Frag bucket ptr */
+	u32			seq;		/* TCP sequence number (if present) */
+	u32			ack_seq;	/* TCP acknowledge number (if present) */
+	int			qos_level;
+	struct cvm_vlan_hdr	vlan;
+	struct cvm_vxlan_hdr	vxlan;
+	struct cvm_pppoe_hdr	pppoe;
+	struct gre_hdr_info	gre;
+	union {
+		struct iphdr_new	outer_ip4;	/* IP header */
+		struct ipv6hdr_new	outer_ip6;
+	};
+	struct cvm_udphdr	outer_udp;
+	union {
+		struct {
+			u32			old_reserved1;
+			struct iphdr_new	cvm_ip;	/* IP header */
+			u64			reserved2[2]; 
+		} cvm_ip4;
+		struct ipv6hdr_new  cvm_ip6;
+	} cvm_ip4_ip6_u;
+	u64	reserved2[2];	/* L4 ports and reserved */
+#define cvmip                            cvm_ip4_ip6_u.cvm_ip4.cvm_ip
+#define cvmip6                           cvm_ip4_ip6_u.cvm_ip6
+} cvm_packet_info_t;
+#endif
+
+
+
+
+
 /** 
  *	struct sk_buff - socket buffer
  *	@next: Next buffer in list
@@ -417,7 +540,7 @@ struct sk_buff {
 	 * want to keep them across layers you have to do a skb_clone()
 	 * first. This is owned by whoever has the skb queued ATM.
 	 */
-	char			cb[48] __aligned(8);
+	char			cb[48+64] __aligned(8);
 #if defined(CONFIG_IMQ) || defined(CONFIG_IMQ_MODULE)
 	void			*cb_next;
 #endif
@@ -520,6 +643,9 @@ struct sk_buff {
 	sk_buff_data_t		transport_header;
 	sk_buff_data_t		network_header;
 	sk_buff_data_t		mac_header;
+#ifdef CONFIG_CAVIUM_OCTEON_IPFWD_OFFLOAD
+	cvm_packet_info_t	cvm_info;
+#endif
 	/* These elements must be at the end, see alloc_skb() for details.  */
 	sk_buff_data_t		tail;
 	sk_buff_data_t		end;
diff -purBN --no-dereference OCTEON-SDK.orig/linux/kernel/linux/include/liteon_config.h OCTEON-SDKsffnand/linux/kernel/linux/include/liteon_config.h
--- OCTEON-SDK.orig/linux/kernel/linux/include/liteon_config.h	1970-01-01 08:00:00.000000000 +0800
+++ OCTEON-SDKsffnand/linux/kernel/linux/include/liteon_config.h	2017-02-12 12:12:23.951464800 +0800
@@ -0,0 +1,2 @@
+#define SYS_REVISION "21"
+#define FW_VERSION "0.1.17"
